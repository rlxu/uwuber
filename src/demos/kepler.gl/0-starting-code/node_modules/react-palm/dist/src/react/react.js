"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var RealReact = require("react");
var PropTypes = require("prop-types");
var react_1 = require("react");
var react_dom_1 = require("react-dom");
// import {isAction} from '../actions';
function isAction(maybeAction) {
    return Boolean(maybeAction.type);
}
/*
 * We wrap React's create element to give us an event bus.
 * This lets us eliminate the need for `mapDispatchToProps` or
 * calling `connect` anywhere but at the application root.
 *
 * This has exactly the same function signature as `React.createElement`.
 * See: https://facebook.github.io/react/docs/react-api.html#createelement
 */
var createElement = function (type, props) {
    var children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
    }
    if (!props || typeof props !== 'object') {
        return react_1.createElement.apply(void 0, [type, props].concat(children));
    }
    var child = function (unwrapped, _a) {
        var dispatch = _a.dispatch;
        var props = wrapProps(unwrapped, dispatch);
        return react_1.createElement.apply(void 0, [type, props].concat(unwrapped.children));
    };
    child.contextTypes = {
        dispatch: RealReact.PropTypes.func
    };
    return react_1.createElement.apply(void 0, [child, props].concat(children));
};
/*
 * Given a map of props:
 * `{ onClick: () => 'hi', label: 'bar' }`
 * And a `dispatch` function, wrap all functions that might be event handlers:
 * `{ onClick: () => (dispatch('hi'), 'hi'), label: 'bar' }`
 */
function wrapProps(props, dispatch) {
    return Object.keys(props).reduce(function (newProps, name) {
        var prop = props[name];
        newProps[name] = (typeof prop === 'function') ?
            wrapEventHandler(prop, dispatch) :
            prop;
        return newProps;
    }, {});
}
function wrapEventHandler(fn, dispatch) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var result = fn.apply(void 0, args);
        if (isAction(result)) {
            dispatch(result);
        }
        return result;
    };
}
exports.React = __assign({}, RealReact, { createElement: createElement });
exports.default = exports.React;
/*
 *
 */
var CONTEXT_WITH_DISPATCH = {
    dispatch: PropTypes.func
};
function withDispatch(dispatch, childElement) {
    var Dispatch = (function (_super) {
        __extends(Dispatch, _super);
        function Dispatch() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Dispatch.prototype.getChildContext = function () {
            return { dispatch: dispatch };
        };
        Dispatch.prototype.render = function () {
            var children = this.props.children;
            return children.length > 1 ? (exports.React.createElement("div", null, children)) : children;
        };
        Dispatch.childContextTypes = CONTEXT_WITH_DISPATCH;
        return Dispatch;
    }(react_1.Component));
    return react_1.createElement(Dispatch, null, childElement);
}
exports.withDispatch = withDispatch;
/*
 * Takes a fn and a react element, returns a wrapped react element that
 * composes over `fn` before calling dispatch
 */
function mapDispatch(fn, childElement) {
    var MapDispatch = (function (_super) {
        __extends(MapDispatch, _super);
        function MapDispatch() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MapDispatch.prototype.getChildContext = function () {
            var dispatch = this.context.dispatch;
            return {
                dispatch: function (action) { return dispatch(fn(action)); }
            };
        };
        MapDispatch.prototype.render = function () {
            var children = this.props.children;
            return children.length > 1 ? (exports.React.createElement("div", null, children)) : children;
        };
        MapDispatch.childContextTypes = CONTEXT_WITH_DISPATCH;
        MapDispatch.contextTypes = CONTEXT_WITH_DISPATCH;
        return MapDispatch;
    }(react_1.Component));
    return (exports.React.createElement(MapDispatch, null, childElement));
}
exports.mapDispatch = mapDispatch;
/*
 * Just like React's render, except that it also takes a `dispatch` function.
 * Whenever an event handler returns an action, dispatch is called with that action.
 */
function render(component, container, dispatch) {
    return react_dom_1.render(withDispatch(dispatch, component), container);
}
exports.render = render;
//# sourceMappingURL=react.js.map