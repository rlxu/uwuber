"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tasks_1 = require("../tasks");
var actions_1 = require("../actions");
var history_1 = require("../history");
var INITIAL_STATE = {
    path: '',
    query: {},
    hash: '',
    routes: []
};
var isString = function (s) { return typeof (s) === 'string' || s instanceof String; };
var deserializeQuery = function (query) {
    if (!query) {
        return {};
    }
    return query.split('&').reduce(function (out, cur) {
        var _a = cur.split('='), key = _a[0], v = _a[1];
        var value = v ? decodeURIComponent(v.replace(/\+/g, ' ')) : '';
        return __assign({}, out, (_b = {}, _b[key] = value, _b));
        var _b;
    }, {});
};
var serializeQuery = function (query) {
    var keys = Object.keys(query);
    if (!keys.length) {
        return '';
    }
    var queryString = keys
        .map(function (key) { return "" + encodeURIComponent(key) + (query[key] ? "=" + encodeURIComponent(query[key]) : ''); })
        .join('&');
    return "?" + queryString;
};
exports.LOCATION_CHANGE = actions_1.createAction('LOCATION_CHANGE');
exports.HISTORY_PUSH = actions_1.createAction('HISTORY_PUSH');
exports.REPLACE = actions_1.createAction('REPLACE');
/**
 * Create the router that gets passed the routes object definition
 * and an optional onChange callback.
 * Return the handlers, serialized routes and useful actions to interact
 * with the history and location.
 *
 * createRouter({ home: '/' })
 * --> { handlers, routes, INITIAL_STATE, HISTORY_PUSH, LOCATION_CHANGE }
 */
function createRouter(routes, onChange) {
    if (onChange === void 0) { onChange = function (state) { return state; }; }
    var historyHandler = function (task) { return function (state, path) {
        var newState = updateRoute(state, path);
        var newPath = "" + newState.path + serializeQuery(newState.query);
        return tasks_1.withTask(newState, task(newPath));
    }; };
    var handlers = (_a = {},
        _a[exports.HISTORY_PUSH] = historyHandler(history_1.HISTORY_PUSH_TASK),
        _a[exports.REPLACE] = historyHandler(history_1.REPLACE_TASK),
        _a[exports.LOCATION_CHANGE] = function (state, path) { return updateRoute(state, path); },
        _a);
    var serialize = function (route, parentUrl) {
        if (parentUrl === void 0) { parentUrl = ''; }
        return function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            var serializedRoute = "" + parentUrl + (_a = route.url).serialize.apply(_a, params);
            if (!route.childRoutes) {
                return serializedRoute;
            }
            return Object.assign(function () { return serializedRoute; }, mapKeys(route.childRoutes, function (route) { return serialize(route, serializedRoute); }));
            var _a;
        };
    };
    var serializedRoutes = mapKeys(routes, serialize);
    var updateRoute = function (state, fullPath) {
        var _a = fullPath.split('#'), withoutHash = _a[0], _b = _a[1], hash = _b === void 0 ? '' : _b;
        var _c = withoutHash.split('?'), path = _c[0], queryString = _c[1];
        var query = deserializeQuery(queryString);
        var matched = deepMatchRoutes(routes, path);
        // If it's a redirect string, pass matched route part and rebuild full url
        // with potential querystring and hash.
        if (isString(matched)) {
            return updateRoute(state, "" + matched + (queryString ? "?" + queryString : '') + (hash ? "#" + hash : ''));
        }
        var nextState = {
            path: path,
            hash: hash,
            query: query,
            routes: matched || []
        };
        return onChange(nextState);
    };
    /**
     * Recursively iterate over routes and their children in order to return
     * matched components and associated params by deserializing them with the
     * current path.
     *
     * deepMatchRoutes({user: {url: u`/users/${{uid: Number}}`, component: User}}, '/users/1', params)
     * --> [{component: User, params: {uid: 1}}]
     */
    var deepMatchRoutes = function (curRoutes, path, dadParams) {
        if (dadParams === void 0) { dadParams = {}; }
        return Object.keys(curRoutes).reduce(function (out, key) {
            if (out) {
                return out;
            }
            var route = curRoutes[key];
            var component = route.component, redirectTo = route.redirectTo, childRoutes = route.childRoutes, url = route.url;
            var maybeMatch = url.deserialize(path);
            if (!maybeMatch) {
                return;
            }
            var params = maybeMatch.params, remainingPath = maybeMatch.remainingPath;
            var fullParams = __assign({}, params, dadParams);
            if (redirectTo) {
                return isString(redirectTo) ? redirectTo : redirectTo(serializedRoutes, fullParams);
            }
            // If the remaining path is empty, we can short-circuit
            if (remainingPath.length === 0) {
                return [{ component: component, params: params }];
            }
            else if (childRoutes) {
                var childMaybeMatch = deepMatchRoutes(childRoutes, remainingPath, fullParams);
                // Check redirect string
                if (isString(childMaybeMatch)) {
                    return childMaybeMatch;
                }
                else if (childMaybeMatch) {
                    return [{ params: params, component: component }].concat(childMaybeMatch);
                }
            }
        }, null);
    };
    return {
        handlers: handlers,
        routes: serializedRoutes,
        INITIAL_STATE: INITIAL_STATE,
        HISTORY_PUSH: exports.HISTORY_PUSH,
        LOCATION_CHANGE: exports.LOCATION_CHANGE,
        REPLACE: exports.REPLACE
    };
    var _a;
}
exports.createRouter = createRouter;
/**
 * Takes the route object and a function, and create a new object where the keys
 * are identical, but assign each value to the return value of the function that
 * get passed the original value.
 *
 * mapKeys({ home: 1, user: 2 }, v => v + 1)
 * --> { home: 2, user: 3 }
 */
var mapKeys = function (obj, fn) {
    return Object.keys(obj).reduce(function (out, key) {
        return (out[key] = fn(obj[key]), out);
    }, {});
};
/**
 * Transform the route template string tag into its parametized equivalent.
 *
 * uHelper`/users/${{uid: Number}}`
 * --> '/users/:uid'
 */
exports.uHelper = function (strings) {
    var params = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        params[_i - 1] = arguments[_i];
    }
    return strings
        .reduce(function (out, cur, index) {
        var param = params[index] ? ":" + Object.keys(params[index])[0] : '';
        return "" + out + cur + param;
    }, '');
};
/**
 * Transform the route template string tag into an object with serialize and
 * deserialize methods.
 *
 * u`/users/${{uid: Number}}`
 * --> { serialize: Function, deserialize: Function }
 */
exports.u = function (strings) {
    var params = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        params[_i - 1] = arguments[_i];
    }
    return ({
        serialize: function (parameters) {
            return strings.reduce(function (out, cur, index) {
                var param = params[index] ? parameters[Object.keys(params[index])[0]] : '';
                return "" + out + cur + param;
            }, '');
        },
        deserialize: function (url) {
            return matchPattern(exports.uHelper.apply(void 0, [strings].concat(params)), url);
        }
    });
};
// The following functions are adapted from react-router.
var escapeRegExp = function (text) { return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); };
/**
 * Match every component of the route pattern and extract its tokens.
 */
var compilePattern = function (pattern) {
    var regexpSource = '';
    var paramNames = [];
    var tokens = [];
    var match;
    var lastIndex = 0;
    var matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)/g;
    while ((match = matcher.exec(pattern))) {
        if (match.index !== lastIndex) {
            tokens.push(pattern.slice(lastIndex, match.index));
            regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));
        }
        if (match[1]) {
            regexpSource += '([^/]+)';
            paramNames.push(match[1]);
        }
        else if (match[0] === '**') {
            regexpSource += '(.*)';
            paramNames.push('splat');
        }
        else if (match[0] === '*') {
            regexpSource += '(.*?)';
            paramNames.push('splat');
        }
        else if (match[0] === '(') {
            regexpSource += '(?:';
        }
        else if (match[0] === ')') {
            regexpSource += ')?';
        }
        tokens.push(match[0]);
        lastIndex = matcher.lastIndex;
    }
    if (lastIndex !== pattern.length) {
        tokens.push(pattern.slice(lastIndex, pattern.length));
        regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));
    }
    return {
        pattern: pattern,
        regexpSource: regexpSource,
        paramNames: paramNames,
        tokens: tokens
    };
};
/**
 * Match the pattern with a path
 */
var matchPattern = function (pattern, path) {
    // Ensure pattern starts with leading slash for consistency with path.
    if (pattern.charAt(0) !== '/') {
        pattern = "/" + pattern;
    }
    if (path.charAt(0) !== '/') {
        path = "/" + path;
    }
    var compiled = compilePattern(pattern);
    var paramNames = compiled.paramNames, tokens = compiled.tokens;
    var regexpSource = compiled.regexpSource;
    // Allow optional path separator at end.
    if (pattern.charAt(pattern.length - 1) !== '/') {
        regexpSource += '/?';
    }
    // Special-case patterns like '*' for catch-all routes.
    if (tokens[tokens.length - 1] === '*') {
        regexpSource += '$';
    }
    var match = path.match(new RegExp("^" + regexpSource, 'i'));
    if (match === null) {
        return null;
    }
    var matchedPath = match[0];
    var remainingPath = path.substr(matchedPath.length);
    if (remainingPath) {
        // Require that the match ends at a path separator, if we didn't match
        // the full path, so any remaining path is a new segment.
        if (matchedPath.charAt(matchedPath.length - 1) !== '/') {
            return null;
        }
        // If there is a remaining path, treat the path separator as part of
        // the remaining path for properly continuing the match.
        remainingPath = "/" + remainingPath;
    }
    var paramValues = match.slice(1).map(function (v) { return v && decodeURIComponent(v); });
    var params = paramNames.reduce(function (reduced, paramName, index) {
        reduced[paramName] = paramValues[index];
        return reduced;
    }, {});
    return { params: params, remainingPath: remainingPath };
};
//# sourceMappingURL=index.js.map