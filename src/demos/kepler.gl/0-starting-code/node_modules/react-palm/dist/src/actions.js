"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ACTION_CREATOR = Symbol('ACTION_CREATOR');
var ACTION_MARKER = Symbol('ACTION_MARKER');
var DEFAULT_ACTION_NAME = 'ACTION';
var FN_NAME_CONFIGURABLE = Object.getOwnPropertyDescriptor(function () { }, 'name').configurable;
/*
 * Creates an action creator with the identity of the action creator as the type.
 * Params passed to the action creator are mapped to the payload property.
 *
 * ```
 * const MY_ACTION = createAction('MY_ACTION');
 * const action = MY_ACTION({user: 123});
 * > {type: MY_ACTION, payload: {user: 123}};
 * ```
 */
function createAction(name) {
    if (name === void 0) { name = DEFAULT_ACTION_NAME; }
    var action = function (payload) {
        if (payload === void 0) { payload = {}; }
        return (_a = { type: action, payload: payload }, _a[ACTION_MARKER] = true, _a);
        var _a;
    };
    var uniqueSymbol = Symbol(name);
    if (name !== DEFAULT_ACTION_NAME && FN_NAME_CONFIGURABLE) {
        Object.defineProperty(action, 'name', { value: name });
    }
    action.toString = function () { return uniqueSymbol; };
    // this valueOf hack is questionable. some polyfills depend on either
    // valueOf or toString returning a simple primative. Since we're overriding
    // toString (also admittedly questionable), we need toValue to return a string.
    action.valueOf = function () { return name; };
    action[ACTION_CREATOR] = true;
    return action;
}
exports.createAction = createAction;
function isAction(maybeAction) {
    return Boolean(maybeAction[ACTION_MARKER]);
}
exports.isAction = isAction;
/*
 * Takes a map from action to handlers, and returns a reducer:
 *
 * ```
 * const reduer = handleActions({
 *   [MY_ACTION]: (state, payload) => ({ users: payload.users })
 * })
 * ```
 *
 * The handler is called with the given state passed to the reduer as a first argument,
 * and the payload of the action as the second argument.
 *
 * Inspired by a function of the same name from the `redux-actions` library,
 * but differs in that the returned reducer throws if called with an action type
 * not provided as a key in handleActions. It also allows function identity as a
 * handler key, and enforces the "flux standard action" spec.
 */
function strictHandleActions(handlersMap, initialState) {
    return function actionHandler(state, action) {
        var extra = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            extra[_i - 2] = arguments[_i];
        }
        if (state === undefined) {
            return initialState;
        }
        if (action[ACTION_CREATOR]) {
            var actionName = toString(action);
            throw new Error('Reducer should be called with an action, not an action creator. ' +
                ("Try \"dispatch(" + actionName + "())\" instead of \"dispatch(" + actionName + ")\""));
        }
        var handler = handlersMap[action.type];
        if (handler) {
            var result = handler.apply(void 0, [state, action.payload].concat(extra));
            if (result === void 0) {
                throw new Error("Handler for action of type \"" + toString(action.type) + "\" returned \"undefined\".");
            }
            return result;
        }
        throw new Error("Unknown action type \"" + toString(action.type) + "\".");
    };
}
exports.strictHandleActions = strictHandleActions;
/*
 * Same as `handleActions`, but does not throw for unknown actions, and allows non-standard
 * actions.
 */
function laxHandleActions(handlersMap, initialState) {
    return function actionHandler(state, action) {
        var extra = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            extra[_i - 2] = arguments[_i];
        }
        if (state === undefined) {
            return initialState;
        }
        var handler = handlersMap[action.type];
        if (handler) {
            // if it's a "flux standard action" just call with the payload to reduce boilerplate
            if (!action.payload) {
                return handler.apply(void 0, [state, action].concat(extra));
            }
            return handler.apply(void 0, [state, action.payload].concat(extra));
        }
        return state;
    };
}
exports.laxHandleActions = laxHandleActions;
function toString(maybeString) {
    if (typeof maybeString === 'function' && maybeString.name) {
        return maybeString.name;
    }
    while (typeof maybeString !== 'string') {
        maybeString = maybeString.toString();
    }
}
exports.handleActions = strictHandleActions;
//# sourceMappingURL=actions.js.map