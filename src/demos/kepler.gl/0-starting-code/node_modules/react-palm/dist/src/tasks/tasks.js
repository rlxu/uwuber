"use strict";
/*
 * Interfaces
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Implementation
 */
var TASK_RUN = Symbol('TASK_RUN');
var ANCESTOR_SUCCESS = Symbol('ANCESTOR_SUCCESS');
var ANCESTOR_ERROR = Symbol('ANCESTOR_ERROR');
function IDENTITY(value) {
    return value;
}
var tasks = [];
// used for debugging
var enableStackCapture = true;
var lastWithTaskCall = null;
var IMPROPER_TASK_USAGE = "Tasks should not be added outside of reducers.";
/*
 * Use this to create a new task
 */
function taskCreator(run, type) {
    return function (payload) {
        var newTask = _task(payload, function (payload, success, error) {
            reportEffects('start', newTask, newTask.payload);
            return run(payload, function (result) {
                reportEffects('success', newTask, result);
                return success(result);
            }, function (reason) {
                reportEffects('error', newTask, reason);
                return error(reason);
            });
        }, IDENTITY, IDENTITY, type);
        return newTask;
    };
}
exports.taskCreator = taskCreator;
function _task(payload, run, mockSuccess, mockError, type) {
    var newTask = (_a = {
            type: type,
            payload: payload
        },
        _a[TASK_RUN] = run,
        _a[ANCESTOR_SUCCESS] = mockSuccess,
        _a[ANCESTOR_ERROR] = mockError,
        _a.map = function (transform) {
            return this.bimap(transform);
        },
        _a.bimap = function (successTransform, errorTransform) {
            return _task(payload, function (payload, success, error) {
                return run(payload, function (result) {
                    return success(successTransform(result));
                }, function (reason) {
                    return error(errorTransform(reason));
                });
            }, function (value) { return successTransform(mockSuccess(value)); }, function (reason) { return errorTransform(mockError(reason)); }, type);
        },
        _a.chain = function (chainTransform) {
            return _task(payload, function (payload, success, error) {
                return run(payload, function (result) {
                    var chainTask = chainTransform(result);
                    return chainTask[TASK_RUN](chainTask.payload, success, error);
                });
            }, function (value) { return chainTransform(mockSuccess(value)); }, mockError, "Chain(" + type + ")");
        },
        _a);
    return newTask;
    var _a;
}
var CACHED_PROMISE = Promise.resolve();
var makeDispatchAsync = function (dispatch) { return function (action) { return CACHED_PROMISE.then(function () { return dispatch(action); }); }; };
/*
 * You need to install this middleware for tasks to have their handlers run.
 *
 * You probably do not want to use this middleware within your test environment.
 * Instead, use `drainTasksForTesting` to retrieve and make assertions about them.
 */
exports.taskMiddleware = function (store) { return function (next) { return function (action) {
    if (!module.hot && enableStackCapture && tasks.length > 0) {
        var err = lastWithTaskCall;
        lastWithTaskCall = null;
        throw err;
    }
    next(action);
    var dispatch = makeDispatchAsync(store.dispatch);
    if (tasks.length > 0) {
        var taskResolutions = tasks.map(function (task) {
            assertTaskIsRunnable(task);
            return task[TASK_RUN](task.payload, dispatch, dispatch);
        });
        tasks = [];
        lastWithTaskCall = null;
        return Promise.all(taskResolutions);
    }
    return CACHED_PROMISE;
}; }; };
/*
 * Use this function in your reducer to add tasks to an action handler.
 */
function withTask(state, task) {
    if (!module.hot && enableStackCapture && !lastWithTaskCall) {
        lastWithTaskCall = trace(IMPROPER_TASK_USAGE);
    }
    if (task instanceof Array) {
        tasks.forEach(assertTaskIsRunnable);
        tasks = tasks.concat(task);
    }
    else {
        assertTaskIsRunnable(task);
        tasks.push(task);
    }
    return state;
}
exports.withTask = withTask;
function assertTaskIsRunnable(task) {
    if (typeof task[TASK_RUN] !== 'function') {
        var taskName = typeof task.type === 'function' ?
            "Function(" + toString(task.type) + ")" : toString(task.type);
        throw new Error("Task of type \"" + taskName + "\" does not have a handler. " +
            "Make sure that you created it with \"taskCreator\".");
    }
}
/*
 * This function should only be used in test environments to make assertions about
 * tasks as part of the test. Application code should not be mucking around with
 * the list of tasks. If you want to display information about tasks in your component,
 * add that information to your state tree when you create the task.
 */
function drainTasksForTesting() {
    var drained = tasks;
    tasks = [];
    lastWithTaskCall = null;
    return drained;
}
exports.drainTasksForTesting = drainTasksForTesting;
/*
 * This function will call `success` from the base task so that any
 * calls to `map` will be called before returning.
 */
function succeedTaskInTest(someTask, value) {
    if (value === void 0) { value = null; }
    return someTask[ANCESTOR_SUCCESS](value);
}
exports.succeedTaskInTest = succeedTaskInTest;
function errorTaskInTest(someTask, reason) {
    if (reason === void 0) { reason = ''; }
    return someTask[ANCESTOR_ERROR](reason);
}
exports.errorTaskInTest = errorTaskInTest;
/*
 * In order to make it easy to track down incorrect uses for `withTask`, we capture exception
 * objects for every call to withTask. This has some performance overhead, so you'll
 * probably want to disable it in production.
 */
function disableStackCapturing() {
    enableStackCapture = false;
}
exports.disableStackCapturing = disableStackCapturing;
/*
 * Record the inputs/outputs of all tasks, possibly for
 * generating tests.
 */
var reportEffects = function (event, task, payload) { };
function reportTasksForTesting(fn) {
    reportEffects = fn;
}
exports.reportTasksForTesting = reportTasksForTesting;
var all = function (tasks) {
    return _task(null, function (_, success, error) {
        if (tasks.length === 0) {
            return success([]);
        }
        var results = tasks.map(function (_) { return null; });
        var remaining = tasks.length;
        var failed = false;
        return Promise.all(tasks.map(function (taskI, index) {
            return taskI[TASK_RUN](taskI.payload, function (result) {
                if (failed) {
                    return;
                }
                remaining -= 1;
                results[index] = result;
                if (remaining === 0) {
                    success(results);
                }
            }, function (reason) {
                if (failed) {
                    return;
                }
                failed = true;
                error(reason);
            });
        }));
    }, function (values) {
        return tasks.map(function (taskI, index) {
            return succeedTaskInTest(taskI, values[index]);
        });
    }, function (reasons) {
        return tasks.map(function (taskI, index) {
            return errorTaskInTest(taskI, reasons[index]);
        });
    }, 'Task.all(' + tasks.map(function (_a) {
        var type = _a.type;
        return toString(type);
    }).join(', ') + ')');
};
exports.Task = {
    all: all,
    map: function (t, f) {
        return t.map(f);
    },
    bimap: function (t, f, f2) {
        return t.bimap(f, f2);
    },
    chain: function (t, chainTransform) { return t.chain(chainTransform); }
};
/*
 * Helpers
 */
function trace(message) {
    try {
        throw new Error(message);
    }
    catch (e) {
        return e;
    }
}
// Converts a function or toString-able to a human-readable string
// for debugging.
function toString(maybeString) {
    if (typeof maybeString === 'function' && maybeString.name) {
        return maybeString.name;
    }
    return maybeString.toString();
}
//# sourceMappingURL=tasks.js.map