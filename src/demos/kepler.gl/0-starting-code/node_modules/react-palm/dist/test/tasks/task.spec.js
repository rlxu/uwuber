"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ava_1 = require("ava");
var sinon_1 = require("sinon");
var tasks_1 = require("../../src/tasks");
var fixtures_1 = require("./fixtures");
// tasks
var xhrHandlerSpy = sinon_1.spy();
var XHR_TASK = tasks_1.taskCreator(xhrHandlerSpy, 'XHR_TASK');
var ADD = function (payload) { return ({ type: ADD, payload: payload }); };
var SET_SYNC = function (payload) { return ({ type: SET_SYNC, payload: payload }); };
var SET_ASYNC = function (payload) { return ({ type: SET_ASYNC, payload: payload }); };
var SET_SUCCESS = function (payload) { return ({ type: SET_SUCCESS, payload: payload }); };
var BAD = function () { return ({ type: BAD, payload: {} }); };
exports.reducer = function (state, action) {
    if (state === void 0) { state = 0; }
    var payload = action.payload;
    switch (action.type) {
        case ADD:
            var newAmount = state + payload;
            return tasks_1.withTask(newAmount, [XHR_TASK(newAmount)]);
        case SET_SYNC:
            return tasks_1.withTask(state, [fixtures_1.SET_TASK_SYNC(payload).map(SET_SUCCESS)]);
        case SET_ASYNC:
            return tasks_1.withTask(state, [fixtures_1.SET_TASK_ASYNC(payload).map(SET_SUCCESS)]);
        case SET_SUCCESS:
            return payload;
        case BAD:
            return tasks_1.withTask(state, BAD());
        default:
            return state;
    }
};
exports.withHelpers = function (testFn) {
    var store = fixtures_1.taskStore(exports.reducer);
    return function (t) { return testFn({ t: t, store: store }); };
};
ava_1.default('Task middleware runs handlers', exports.withHelpers(function (_a) {
    var t = _a.t, store = _a.store;
    store.dispatch(ADD(3));
    var firstCallFirstArg = xhrHandlerSpy.args[0][0];
    t.is(firstCallFirstArg, 3);
    t.is(store.getState(), 3);
    // the middleware should consume all of the tasks
    var tasks = tasks_1.drainTasksForTesting();
    t.deepEqual(tasks, []);
}));
ava_1.default('Task middleware throws when task not created properly', exports.withHelpers(function (_a) {
    var t = _a.t, store = _a.store;
    t.throws(function () { return store.dispatch(BAD()); }, "Task of type \"Function(BAD)\" does not have a handler. Make sure that you created it with \"taskCreator\".");
}));
ava_1.default('Task middleware throws when tasks were added incorrectly', exports.withHelpers(function (_a) {
    var t = _a.t, store = _a.store;
    var incorrectTaskAdd = function () { return tasks_1.withTask(null, XHR_TASK('test123')); };
    incorrectTaskAdd();
    t.throws(function () { return store.dispatch(ADD(3)); }, "Tasks should not be added outside of reducers.");
    tasks_1.drainTasksForTesting();
    var stack = '';
    try {
        incorrectTaskAdd();
        store.dispatch(ADD(3));
    }
    catch (e) {
        stack = e.stack;
    }
    t.regex(stack, /incorrectTaskAdd/, 'Error includes stack of the first incorrect task usage');
    tasks_1.drainTasksForTesting();
}));
ava_1.default.cb('Task middleware works with sync task handler', exports.withHelpers(function (_a) {
    var t = _a.t, store = _a.store;
    t.plan(3);
    t.is(store.getState(), 0);
    store.dispatch(SET_SYNC(42));
    // Fake tick to wait for the dispatchAsync to be finished
    setTimeout(function () {
        t.is(store.getState(), 42);
        t.end();
    }, 0);
    var tasks = tasks_1.drainTasksForTesting();
    t.deepEqual(tasks, []);
}));
ava_1.default.cb('Task middleware works with async task handler', exports.withHelpers(function (_a) {
    var t = _a.t, store = _a.store;
    t.plan(4);
    t.is(store.getState(), 0);
    var promise = store.dispatch(SET_ASYNC(43));
    t.is(store.getState(), 0);
    var tasks = tasks_1.drainTasksForTesting();
    t.deepEqual(tasks, []);
    promise.then(function () {
        t.is(store.getState(), 43);
        t.end();
    });
}));
//# sourceMappingURL=task.spec.js.map