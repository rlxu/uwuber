"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ava_1 = require("ava");
var sinon_1 = require("sinon");
var redux_1 = require("redux");
var subscriptions_1 = require("../src/subscriptions");
ava_1.default('Middleware only calls schedulers when subscriptions change', function (t) {
    var fakeState = {};
    function MY_SUB(params, action) {
        return { type: MY_SUB, params: params, action: action };
    }
    var MY_ACTION = sinon_1.spy();
    var myScheduler = sinon_1.spy();
    subscriptions_1.makeSubscriptionType(MY_SUB, myScheduler);
    var sub = MY_SUB(123, MY_ACTION);
    var subs = [sub];
    var subscribe = function (_) { return subs; };
    var subMiddleware = subscriptions_1.makeSubscriptionMiddleware(subscribe);
    var store = redux_1.createStore(function () { return fakeState; }, redux_1.applyMiddleware(subMiddleware));
    var args = myScheduler.firstCall.args;
    t.is(args.length, 3, 'Scheduler called with three args');
    // we cannot know the identity of the dispatch function because of middleware
    // asserting that the first arg is in fact a function is good enough
    t.is(typeof args[0], 'function', 'Scheduler called with dispatch fn as first arg');
    t.deepEqual(args[1], [sub]);
    t.deepEqual(args[2], []);
    store.dispatch({ type: 'DUMMY' });
    // because our subscriptions are the same, we should not call the scheduler again
    t.true(myScheduler.calledOnce);
    // however, if subscriptions change, the scheduler should be called again
    subs = [];
    store.dispatch({ type: 'DUMMY' });
    t.true(myScheduler.calledTwice);
    // This time, we should see no subs added (arg[1]) and the existing sub removed (arg[2])
    args = myScheduler.secondCall.args;
    t.is(typeof args[0], 'function', 'Scheduler called with dispatch fn as first arg');
    t.deepEqual(args[1], []);
    t.deepEqual(args[2], [sub]);
});
//# sourceMappingURL=subscription.spec.js.map