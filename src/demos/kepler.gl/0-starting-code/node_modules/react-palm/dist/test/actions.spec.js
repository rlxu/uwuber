"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ava_1 = require("ava");
var sinon_1 = require("sinon");
var actions_1 = require("../src/actions");
var MY_ACTION = actions_1.createAction();
ava_1.default('handleActions works', function (t) {
    var reducer = actions_1.handleActions((_a = {},
        _a[MY_ACTION.toString()] = function (state, _a) {
            var items = _a.items;
            return items;
        },
        _a), {});
    var payload = { hi: 'there' };
    t.deepEqual(reducer({ old: 'value' }, MY_ACTION({ items: payload })), payload);
    var _a;
});
ava_1.default('handleActions reducer throws when a handler returns undefined', function (t) {
    // TODO: provide a builder API for TS so you don't have to do this `toString` hack
    var reducer = actions_1.handleActions((_a = {},
        _a[MY_ACTION.toString()] = function (state, _a) {
            var items = _a.items;
            return undefined;
        },
        _a), {});
    t.throws(function () { return reducer({}, MY_ACTION()); });
    var _a;
});
ava_1.default('handleActions reducer throws when called with an unknown action type', function (t) {
    var UNKNOWN_ACTION = actions_1.createAction();
    // TODO: provide a builder API for TS so you don't have to do this `toString` hack
    var reducer = actions_1.handleActions((_a = {},
        _a[MY_ACTION.toString()] = function (state, _a) {
            var items = _a.items;
            return items;
        },
        _a), {});
    t.throws(function () { return reducer({}, UNKNOWN_ACTION()); });
    var _a;
});
ava_1.default('handleActions reducer throws when called with an action creator', function (t) {
    // TODO: provide a builder API for TS so you don't have to do this `toString` hack
    var reducer = actions_1.handleActions((_a = {},
        _a[MY_ACTION.toString()] = function (state, _a) {
            var items = _a.items;
            return items;
        },
        _a), {});
    t.throws(function () { return reducer({}, MY_ACTION); });
    var _a;
});
ava_1.default('handleActions reducer throws when called without a payload', function (t) {
    // TODO: provide a builder API for TS so you don't have to do this `toString` hack
    var reducer = actions_1.handleActions((_a = {},
        _a[MY_ACTION.toString()] = function (state, _a) {
            var items = _a.items;
            return items;
        },
        _a), {});
    t.throws(function () { return reducer({}, { type: MY_ACTION }); });
    var _a;
});
ava_1.default('handleActions reducer passes extra params to handler', function (t) {
    var handler = sinon_1.stub();
    handler.returns({});
    // TODO: provide a builder API for TS so you don't have to do this `toString` hack
    var reducer = actions_1.handleActions((_a = {},
        _a[MY_ACTION.toString()] = handler,
        _a), {});
    reducer({}, MY_ACTION(123), 'extra1', { extra: 2 });
    t.deepEqual(handler.firstCall.args, [{}, 123, 'extra1', { extra: 2 }]);
    var _a;
});
ava_1.default('laxHandleActions works', function (t) {
    var reducer = actions_1.laxHandleActions((_a = {},
        _a[MY_ACTION.toString()] = function (state, _a) {
            var items = _a.items;
            return items;
        },
        _a), {});
    var payload = { hi: 'there' };
    t.deepEqual(reducer({ old: 'value' }, MY_ACTION({ items: payload })), payload);
    var _a;
});
ava_1.default('laxHandleActions reducer allows a handler to return undefined', function (t) {
    // TODO: provide a builder API for TS so you don't have to do this `toString` hack
    var reducer = actions_1.laxHandleActions((_a = {},
        _a[MY_ACTION.toString()] = function (state, _a) {
            var items = _a.items;
            return undefined;
        },
        _a), {});
    t.is(reducer({}, MY_ACTION()), undefined);
    var _a;
});
ava_1.default('laxHandleActions reducer returns initial state when called with an unknown action type', function (t) {
    var UNKNOWN_ACTION = actions_1.createAction();
    // TODO: provide a builder API for TS so you don't have to do this `toString` hack
    var reducer = actions_1.laxHandleActions((_a = {},
        _a[MY_ACTION.toString()] = function (state, _a) {
            var items = _a.items;
            return items;
        },
        _a), {});
    var initialState = { one: 'two' };
    t.is(reducer(initialState, UNKNOWN_ACTION()), initialState);
    var _a;
});
ava_1.default('laxHandleActions reducer passes entire action when called without a payload', function (t) {
    // TODO: provide a builder API for TS so you don't have to do this `toString` hack
    var reducer = actions_1.laxHandleActions((_a = {},
        _a[MY_ACTION.toString()] = function (state, action) { return action; },
        _a), {});
    var action = { type: MY_ACTION };
    t.is(reducer({}, action), action);
    var _a;
});
ava_1.default('laxHandleActions reducer passes extra params to handler', function (t) {
    var handler = sinon_1.spy();
    // TODO: provide a builder API for TS so you don't have to do this `toString` hack
    var reducer = actions_1.laxHandleActions((_a = {},
        _a[MY_ACTION.toString()] = handler,
        _a), {});
    reducer({}, MY_ACTION(123), 'extra1', { extra: 2 });
    t.deepEqual(handler.firstCall.args, [{}, 123, 'extra1', { extra: 2 }]);
    var _a;
});
ava_1.default('isAction returns true only for actions from createAction', function (t) {
    t.true(actions_1.isAction(actions_1.createAction('TEST')()));
    t.false(actions_1.isAction({ type: 'NOPE', payload: 'uh-uh' }));
});
//# sourceMappingURL=actions.spec.js.map