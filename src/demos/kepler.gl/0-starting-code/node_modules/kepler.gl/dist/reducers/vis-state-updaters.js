'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadFilesErrUpdater = exports.loadFilesUpdater = exports.updateVisDataUpdater = exports.toggleLayerForMapUpdater = exports.setVisibleLayersForMapUpdater = exports.toggleSplitMapUpdater = exports.mapClickUpdater = exports.layerClickUpdater = exports.layerHoverUpdater = exports.receiveMapConfigUpdater = exports.resetMapConfigUpdater = exports.showDatasetTableUpdater = exports.updateLayerBlendingUpdater = exports.removeDatasetUpdater = exports.reorderLayerUpdater = exports.removeLayerUpdater = exports.addLayerUpdater = exports.removeFilterUpdater = exports.enlargeFilterUpdater = exports.updateAnimationSpeedUpdater = exports.toggleFilterAnimationUpdater = exports.addFilterUpdater = exports.setFilterPlotUpdater = exports.INITIAL_VIS_STATE = undefined;

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _extends13 = require('babel-runtime/helpers/extends');

var _extends14 = _interopRequireDefault(_extends13);

exports.layerConfigChangeUpdater = layerConfigChangeUpdater;
exports.layerTypeChangeUpdater = layerTypeChangeUpdater;
exports.layerVisualChannelChangeUpdater = layerVisualChannelChangeUpdater;
exports.layerVisConfigChangeUpdater = layerVisConfigChangeUpdater;
exports.interactionConfigChangeUpdater = interactionConfigChangeUpdater;
exports.setFilterUpdater = setFilterUpdater;
exports.addDefaultLayers = addDefaultLayers;
exports.addDefaultTooltips = addDefaultTooltips;
exports.updateAllLayerDomainData = updateAllLayerDomainData;

var _window = require('global/window');

var _reactPalm = require('react-palm');

var _tasks = require('react-palm/tasks');

var _tasks2 = require('../tasks/tasks');

var _visStateActions = require('../actions/vis-state-actions');

var _actions = require('../actions');

var _interactionUtils = require('../utils/interaction-utils');

var _utils = require('../utils/utils');

var _filterUtils = require('../utils/filter-utils');

var _datasetUtils = require('../utils/dataset-utils');

var _layerUtils = require('../utils/layer-utils/layer-utils');

var _fileHandler = require('../processors/file-handler');

var _visStateMerger = require('./vis-state-merger');

var _layers = require('../layers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// react-palm
// disable capture exception for react-palm call to withTasks


// Tasks
(0, _tasks.disableStackCapturing)();

// Utils


// Actions
// Copyright (c) 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var INITIAL_VIS_STATE = exports.INITIAL_VIS_STATE = {
  // layers
  layers: [],
  layerData: [],
  layerToBeMerged: [],
  layerOrder: [],

  // filters
  filters: [],
  filterToBeMerged: [],

  // a collection of multiple dataset
  datasets: {},
  editingDataset: undefined,

  interactionConfig: (0, _interactionUtils.getDefaultInteraction)(),
  interactionToBeMerged: undefined,

  layerBlending: 'normal',
  hoverInfo: undefined,
  clicked: undefined,

  fileLoading: false,
  fileLoadingErr: null,

  // this is used when user split maps
  splitMaps: [
    // this will contain a list of objects to
    // describe the state of layer availability and visibility for each map
    // [
    //   {
    //     layers: {
    //       layer_id: {
    //         isAvailable: true|false # this is driven by the left hand panel
    //         isVisible: true|false
    //       }
    //     }
    //   }
    // ]
  ],

  // defaults layer classes
  layerClasses: _layers.LayerClasses
};

function updateStateWithLayerAndData(state, _ref) {
  var layerData = _ref.layerData,
      layer = _ref.layer,
      idx = _ref.idx;

  return (0, _extends14.default)({}, state, {
    layers: state.layers.map(function (lyr, i) {
      return i === idx ? layer : lyr;
    }),
    layerData: layerData ? state.layerData.map(function (d, i) {
      return i === idx ? layerData : d;
    }) : state.layerData
  });
}

/**
 * Called to update layer base config: dataId, label, column, isVisible
 *
 */
function layerConfigChangeUpdater(state, action) {
  var oldLayer = action.oldLayer;

  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var props = Object.keys(action.newConfig);

  var newLayer = oldLayer.updateLayerConfig(action.newConfig);
  if (newLayer.shouldCalculateLayerData(props)) {
    var oldLayerData = state.layerData[idx];

    var _calculateLayerData = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData, { sameData: true }),
        layerData = _calculateLayerData.layerData,
        layer = _calculateLayerData.layer;

    return updateStateWithLayerAndData(state, { layerData: layerData, layer: layer, idx: idx });
  }

  var newState = (0, _extends14.default)({}, state, {
    splitMaps: 'isVisible' in action.newConfig ? toggleLayerFromSplitMaps(state, newLayer) : state.splitMaps
  });

  return updateStateWithLayerAndData(newState, { layer: newLayer, idx: idx });
}

function layerTypeChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      newType = action.newType;

  var oldId = oldLayer.id;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldId;
  });

  if (!state.layerClasses[newType]) {
    _window.console.error(newType + ' is not a valid layer type');
    return state;
  }

  // get a mint layer, with new id and type
  // because deck.gl uses id to match between new and old layer.
  // If type has changed but id is the same, it will break
  var newLayer = new state.layerClasses[newType]();

  newLayer.assignConfigToLayer(oldLayer.config, oldLayer.visConfigSettings);

  if (newLayer.config.dataId) {
    var dataset = state.datasets[newLayer.config.dataId];
    newLayer.updateLayerDomain(dataset);
  }

  var _calculateLayerData2 = (0, _layerUtils.calculateLayerData)(newLayer, state),
      layerData = _calculateLayerData2.layerData,
      layer = _calculateLayerData2.layer;

  var newState = state;

  // update splitMap layer id
  if (state.splitMaps) {
    newState = (0, _extends14.default)({}, state, {
      splitMaps: state.splitMaps.map(function (settings) {
        var _settings$layers = settings.layers,
            oldLayerMap = _settings$layers[oldId],
            otherLayers = (0, _objectWithoutProperties3.default)(_settings$layers, [oldId]);

        return (0, _extends14.default)({}, settings, {
          layers: (0, _extends14.default)({}, otherLayers, (0, _defineProperty3.default)({}, layer.id, oldLayerMap))
        });
      })
    });
  }

  return updateStateWithLayerAndData(newState, { layerData: layerData, layer: layer, idx: idx });
}

function layerVisualChannelChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      newConfig = action.newConfig,
      channel = action.channel;

  var dataset = state.datasets[oldLayer.config.dataId];

  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var newLayer = oldLayer.updateLayerConfig(newConfig);

  newLayer.updateLayerVisualChannel(dataset, channel);

  var oldLayerData = state.layerData[idx];

  var _calculateLayerData3 = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData, {
    sameData: true
  }),
      layerData = _calculateLayerData3.layerData,
      layer = _calculateLayerData3.layer;

  return updateStateWithLayerAndData(state, { layerData: layerData, layer: layer, idx: idx });
}

function layerVisConfigChangeUpdater(state, action) {
  var oldLayer = action.oldLayer;

  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var props = Object.keys(action.newVisConfig);

  var newVisConfig = (0, _extends14.default)({}, oldLayer.config.visConfig, action.newVisConfig);

  var newLayer = oldLayer.updateLayerConfig({ visConfig: newVisConfig });

  if (newLayer.shouldCalculateLayerData(props)) {
    var oldLayerData = state.layerData[idx];

    var _calculateLayerData4 = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData, { sameData: true }),
        layerData = _calculateLayerData4.layerData,
        layer = _calculateLayerData4.layer;

    return updateStateWithLayerAndData(state, { layerData: layerData, layer: layer, idx: idx });
  }

  return updateStateWithLayerAndData(state, { layer: newLayer, idx: idx });
}

/* eslint-enable max-statements */

function interactionConfigChangeUpdater(state, action) {
  var config = action.config;


  var interactionConfig = (0, _extends14.default)({}, state.interactionConfig, (0, _defineProperty3.default)({}, config.id, config));

  if (config.enabled && !state.interactionConfig[config.id].enabled) {
    // only enable one interaction at a time
    Object.keys(interactionConfig).forEach(function (k) {
      if (k !== config.id) {
        interactionConfig[k] = (0, _extends14.default)({}, interactionConfig[k], { enabled: false });
      }
    });
  }

  return (0, _extends14.default)({}, state, {
    interactionConfig: interactionConfig
  });
}

function setFilterUpdater(state, action) {
  var idx = action.idx,
      prop = action.prop,
      value = action.value;

  var newState = state;
  var newFilter = (0, _extends14.default)({}, state.filters[idx], (0, _defineProperty3.default)({}, prop, value));

  var _newFilter = newFilter,
      dataId = _newFilter.dataId;

  if (!dataId) {
    return state;
  }
  var _state$datasets$dataI = state.datasets[dataId],
      fields = _state$datasets$dataI.fields,
      allData = _state$datasets$dataI.allData;


  switch (prop) {
    case 'dataId':
      // if trying to update filter dataId. create an empty new filter
      newFilter = (0, _filterUtils.getDefaultFilter)(dataId);
      break;

    case 'name':
      // find the field
      var fieldIdx = fields.findIndex(function (f) {
        return f.name === value;
      });
      var field = fields[fieldIdx];

      if (!field.filterProp) {
        // get filter domain from field
        // save filterProps: {domain, steps, value} to field, avoid recalculate
        field = (0, _extends14.default)({}, field, {
          filterProp: (0, _filterUtils.getFilterProps)(allData, field)
        });
      }

      newFilter = (0, _extends14.default)({}, newFilter, field.filterProp, {
        name: field.name,
        // can't edit dataId once name is selected
        freeze: true,
        fieldIdx: fieldIdx
      });

      newState = (0, _extends14.default)({}, state, {
        datasets: (0, _extends14.default)({}, state.datasets, (0, _defineProperty3.default)({}, dataId, (0, _extends14.default)({}, state.datasets[dataId], {
          fields: fields.map(function (d, i) {
            return i === fieldIdx ? field : d;
          })
        })))
      });
      break;
    case 'value':
    default:
      break;
  }

  // save new filters to newState
  newState = (0, _extends14.default)({}, newState, {
    filters: state.filters.map(function (f, i) {
      return i === idx ? newFilter : f;
    })
  });

  // filter data
  newState = (0, _extends14.default)({}, newState, {
    datasets: (0, _extends14.default)({}, newState.datasets, (0, _defineProperty3.default)({}, dataId, (0, _extends14.default)({}, newState.datasets[dataId], (0, _filterUtils.filterData)(allData, dataId, newState.filters))))
  });

  newState = updateAllLayerDomainData(newState, dataId, newFilter);

  return newState;
}

var setFilterPlotUpdater = exports.setFilterPlotUpdater = function setFilterPlotUpdater(state, _ref2) {
  var idx = _ref2.idx,
      newProp = _ref2.newProp;

  var newFilter = (0, _extends14.default)({}, state.filters[idx], newProp);
  var prop = Object.keys(newProp)[0];
  if (prop === 'yAxis') {
    var plotType = (0, _filterUtils.getDefaultFilterPlotType)(newFilter);

    if (plotType) {
      newFilter = (0, _extends14.default)({}, newFilter, (0, _filterUtils.getFilterPlot)((0, _extends14.default)({}, newFilter, { plotType: plotType }), state.datasets[newFilter.dataId].allData), {
        plotType: plotType
      });
    }
  }

  return (0, _extends14.default)({}, state, {
    filters: state.filters.map(function (f, i) {
      return i === idx ? newFilter : f;
    })
  });
};

var addFilterUpdater = exports.addFilterUpdater = function addFilterUpdater(state, action) {
  return !action.dataId ? state : (0, _extends14.default)({}, state, {
    filters: [].concat((0, _toConsumableArray3.default)(state.filters), [(0, _filterUtils.getDefaultFilter)(action.dataId)])
  });
};

var toggleFilterAnimationUpdater = exports.toggleFilterAnimationUpdater = function toggleFilterAnimationUpdater(state, action) {
  return (0, _extends14.default)({}, state, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? (0, _extends14.default)({}, f, { isAnimating: !f.isAnimating }) : f;
    })
  });
};

var updateAnimationSpeedUpdater = exports.updateAnimationSpeedUpdater = function updateAnimationSpeedUpdater(state, action) {
  return (0, _extends14.default)({}, state, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? (0, _extends14.default)({}, f, { speed: action.speed }) : f;
    })
  });
};

var enlargeFilterUpdater = exports.enlargeFilterUpdater = function enlargeFilterUpdater(state, action) {
  var isEnlarged = state.filters[action.idx].enlarged;

  return (0, _extends14.default)({}, state, {
    filters: state.filters.map(function (f, i) {
      f.enlarged = !isEnlarged && i === action.idx;
      return f;
    })
  });
};

var removeFilterUpdater = exports.removeFilterUpdater = function removeFilterUpdater(state, action) {
  var idx = action.idx;
  var dataId = state.filters[idx].dataId;


  var newFilters = [].concat((0, _toConsumableArray3.default)(state.filters.slice(0, idx)), (0, _toConsumableArray3.default)(state.filters.slice(idx + 1, state.filters.length)));

  var newState = (0, _extends14.default)({}, state, {
    datasets: (0, _extends14.default)({}, state.datasets, (0, _defineProperty3.default)({}, dataId, (0, _extends14.default)({}, state.datasets[dataId], (0, _filterUtils.filterData)(state.datasets[dataId].allData, dataId, newFilters)))),
    filters: newFilters
  });

  return updateAllLayerDomainData(newState, dataId);
};

var addLayerUpdater = exports.addLayerUpdater = function addLayerUpdater(state, action) {
  var defaultDataset = Object.keys(state.datasets)[0];
  var newLayer = new _layers.Layer((0, _extends14.default)({
    isVisible: true,
    isConfigActive: true,
    dataId: defaultDataset
  }, action.props));

  return (0, _extends14.default)({}, state, {
    layers: [].concat((0, _toConsumableArray3.default)(state.layers), [newLayer]),
    layerData: [].concat((0, _toConsumableArray3.default)(state.layerData), [{}]),
    layerOrder: [].concat((0, _toConsumableArray3.default)(state.layerOrder), [state.layerOrder.length]),
    splitMaps: addNewLayersToSplitMap(state.splitMaps, newLayer)
  });
};

var removeLayerUpdater = exports.removeLayerUpdater = function removeLayerUpdater(state, _ref3) {
  var idx = _ref3.idx;
  var layers = state.layers,
      layerData = state.layerData,
      clicked = state.clicked,
      hoverInfo = state.hoverInfo;

  var layerToRemove = state.layers[idx];
  var newMaps = removeLayerFromSplitMaps(state, layerToRemove);

  return (0, _extends14.default)({}, state, {
    layers: [].concat((0, _toConsumableArray3.default)(layers.slice(0, idx)), (0, _toConsumableArray3.default)(layers.slice(idx + 1, layers.length))),
    layerData: [].concat((0, _toConsumableArray3.default)(layerData.slice(0, idx)), (0, _toConsumableArray3.default)(layerData.slice(idx + 1, layerData.length))),
    layerOrder: state.layerOrder.filter(function (i) {
      return i !== idx;
    }).map(function (pid) {
      return pid > idx ? pid - 1 : pid;
    }),
    clicked: layerToRemove.isLayerHovered(clicked) ? undefined : clicked,
    hoverInfo: layerToRemove.isLayerHovered(hoverInfo) ? undefined : hoverInfo,
    splitMaps: newMaps
  });
};

var reorderLayerUpdater = exports.reorderLayerUpdater = function reorderLayerUpdater(state, _ref4) {
  var order = _ref4.order;
  return (0, _extends14.default)({}, state, {
    layerOrder: order
  });
};

var removeDatasetUpdater = function removeDatasetUpdater(state, action) {
  // extract dataset key
  var datasetKey = action.key;
  var datasets = state.datasets;

  // check if dataset is present

  if (!datasets[datasetKey]) {
    return state;
  }

  /* eslint-disable no-unused-vars */
  var layers = state.layers,
      _state$datasets = state.datasets,
      dataset = _state$datasets[datasetKey],
      newDatasets = (0, _objectWithoutProperties3.default)(_state$datasets, [datasetKey]);
  /* eslint-enable no-unused-vars */

  var indexes = layers.reduce(function (listOfIndexes, layer, index) {
    if (layer.config.dataId === datasetKey) {
      listOfIndexes.push(index);
    }
    return listOfIndexes;
  }, []);

  // remove layers and datasets

  var _indexes$reduce = indexes.reduce(function (_ref5, idx) {
    var currentState = _ref5.newState,
        indexCounter = _ref5.indexCounter;

    var currentIndex = idx - indexCounter;
    currentState = removeLayerUpdater(currentState, { idx: currentIndex });
    indexCounter++;
    return { newState: currentState, indexCounter: indexCounter };
  }, { newState: (0, _extends14.default)({}, state, { datasets: newDatasets }), indexCounter: 0 }),
      newState = _indexes$reduce.newState;

  // remove filters


  var filters = state.filters.filter(function (filter) {
    return filter.dataId !== datasetKey;
  });

  // update interactionConfig
  var interactionConfig = state.interactionConfig;
  var _interactionConfig = interactionConfig,
      tooltip = _interactionConfig.tooltip;

  if (tooltip) {
    var config = tooltip.config;
    /* eslint-disable no-unused-vars */

    var _config$fieldsToShow = config.fieldsToShow,
        fields = _config$fieldsToShow[datasetKey],
        fieldsToShow = (0, _objectWithoutProperties3.default)(_config$fieldsToShow, [datasetKey]);
    /* eslint-enable no-unused-vars */

    interactionConfig = (0, _extends14.default)({}, interactionConfig, {
      tooltip: (0, _extends14.default)({}, tooltip, { config: (0, _extends14.default)({}, config, { fieldsToShow: fieldsToShow }) })
    });
  }

  return (0, _extends14.default)({}, newState, { filters: filters, interactionConfig: interactionConfig });
};

exports.removeDatasetUpdater = removeDatasetUpdater;
var updateLayerBlendingUpdater = exports.updateLayerBlendingUpdater = function updateLayerBlendingUpdater(state, action) {
  return (0, _extends14.default)({}, state, {
    layerBlending: action.mode
  });
};

var showDatasetTableUpdater = exports.showDatasetTableUpdater = function showDatasetTableUpdater(state, action) {
  return (0, _extends14.default)({}, state, {
    editingDataset: action.dataId
  });
};

var resetMapConfigUpdater = exports.resetMapConfigUpdater = function resetMapConfigUpdater(state, action) {
  return (0, _extends14.default)({}, INITIAL_VIS_STATE, state.initialState, {
    initialState: state.initialState
  });
};

/**
 * Loads custom configuration into state
 * @param state
 * @param action
 * @returns {*}
 */
var receiveMapConfigUpdater = exports.receiveMapConfigUpdater = function receiveMapConfigUpdater(state, action) {
  if (!action.payload.visState) {
    return state;
  }

  var _action$payload$visSt = action.payload.visState,
      filters = _action$payload$visSt.filters,
      layers = _action$payload$visSt.layers,
      interactionConfig = _action$payload$visSt.interactionConfig,
      layerBlending = _action$payload$visSt.layerBlending,
      splitMaps = _action$payload$visSt.splitMaps;

  // always reset config when receive a new config

  var resetState = resetMapConfigUpdater(state);
  var mergedState = (0, _extends14.default)({}, resetState, {
    splitMaps: splitMaps || [] // maps doesn't require any logic
  });

  mergedState = (0, _visStateMerger.mergeFilters)(mergedState, filters);
  mergedState = (0, _visStateMerger.mergeLayers)(mergedState, layers);
  mergedState = (0, _visStateMerger.mergeInteractions)(mergedState, interactionConfig);
  mergedState = (0, _visStateMerger.mergeLayerBlending)(mergedState, layerBlending);

  return mergedState;
};

var layerHoverUpdater = exports.layerHoverUpdater = function layerHoverUpdater(state, action) {
  return (0, _extends14.default)({}, state, {
    hoverInfo: action.info
  });
};

var layerClickUpdater = exports.layerClickUpdater = function layerClickUpdater(state, action) {
  return (0, _extends14.default)({}, state, {
    clicked: action.info && action.info.picked ? action.info : null
  });
};

var mapClickUpdater = exports.mapClickUpdater = function mapClickUpdater(state, action) {
  return (0, _extends14.default)({}, state, {
    clicked: null
  });
};

var toggleSplitMapUpdater = exports.toggleSplitMapUpdater = function toggleSplitMapUpdater(state, action) {
  return state.splitMaps && state.splitMaps.length === 0 ? (0, _extends14.default)({}, state, {
    // maybe we should use an array to store state for a single map as well
    // if current maps length is equal to 0 it means that we are about to split the view
    splitMaps: computeSplitMapLayers(state.layers)
  }) : closeSpecificMapAtIndex(state, action);
};

/**
 * This is triggered when view is split into multiple maps.
 * It will only update layers that belong to the map layer dropdown
 * the user is interacting wit
 * @param state
 * @param action
 */
var setVisibleLayersForMapUpdater = exports.setVisibleLayersForMapUpdater = function setVisibleLayersForMapUpdater(state, action) {
  var mapIndex = action.mapIndex,
      layerIds = action.layerIds;

  if (!layerIds) {
    return state;
  }

  var _state$splitMaps = state.splitMaps,
      splitMaps = _state$splitMaps === undefined ? [] : _state$splitMaps;


  if (splitMaps.length === 0) {
    // we should never get into this state
    // because this action should only be triggered
    // when map view is split
    // but something may have happened
    return state;
  }

  // need to check if maps is populated otherwise will create
  var _splitMaps$mapIndex = splitMaps[mapIndex],
      map = _splitMaps$mapIndex === undefined ? {} : _splitMaps$mapIndex;


  var layers = map.layers || [];

  // we set visibility to true for all layers included in our input list
  var newLayers = (Object.keys(layers) || []).reduce(function (currentLayers, idx) {
    return (0, _extends14.default)({}, currentLayers, (0, _defineProperty3.default)({}, idx, (0, _extends14.default)({}, layers[idx], {
      isVisible: layerIds.includes(idx)
    })));
  }, {});

  var newMaps = [].concat((0, _toConsumableArray3.default)(splitMaps));

  newMaps[mapIndex] = (0, _extends14.default)({}, splitMaps[mapIndex], {
    layers: newLayers
  });

  return (0, _extends14.default)({}, state, {
    splitMaps: newMaps
  });
};

var toggleLayerForMapUpdater = exports.toggleLayerForMapUpdater = function toggleLayerForMapUpdater(state, action) {
  if (!state.splitMaps[action.mapIndex]) {
    return state;
  }

  var mapSettings = state.splitMaps[action.mapIndex];
  var layers = mapSettings.layers;

  if (!layers || !layers[action.layerId]) {
    return state;
  }

  var layer = layers[action.layerId];

  var newLayer = (0, _extends14.default)({}, layer, {
    isVisible: !layer.isVisible
  });

  var newLayers = (0, _extends14.default)({}, layers, (0, _defineProperty3.default)({}, action.layerId, newLayer));

  // const splitMaps = state.splitMaps;
  var newSplitMaps = [].concat((0, _toConsumableArray3.default)(state.splitMaps));
  newSplitMaps[action.mapIndex] = (0, _extends14.default)({}, mapSettings, {
    layers: newLayers
  });

  return (0, _extends14.default)({}, state, {
    splitMaps: newSplitMaps
  });
};

/* eslint-disable max-statements */
var updateVisDataUpdater = exports.updateVisDataUpdater = function updateVisDataUpdater(state, action) {
  // datasets can be a single data entries or an array of multiple data entries
  var datasets = Array.isArray(action.datasets) ? action.datasets : [action.datasets];

  if (action.config) {
    // apply config if passed from action
    state = receiveMapConfigUpdater(state, {
      payload: { visState: action.config }
    });
  }

  var newDateEntries = datasets.reduce(function (accu, _ref6) {
    var _ref6$info = _ref6.info,
        info = _ref6$info === undefined ? {} : _ref6$info,
        data = _ref6.data;
    return (0, _extends14.default)({}, accu, (0, _datasetUtils.createNewDataEntry)({ info: info, data: data }, state.datasets) || {});
  }, {});

  if (!Object.keys(newDateEntries).length) {
    return state;
  }

  var stateWithNewData = (0, _extends14.default)({}, state, {
    datasets: (0, _extends14.default)({}, state.datasets, newDateEntries)
  });

  // previously saved config before data loaded
  var _stateWithNewData$fil = stateWithNewData.filterToBeMerged,
      filterToBeMerged = _stateWithNewData$fil === undefined ? [] : _stateWithNewData$fil,
      _stateWithNewData$lay = stateWithNewData.layerToBeMerged,
      layerToBeMerged = _stateWithNewData$lay === undefined ? [] : _stateWithNewData$lay,
      _stateWithNewData$int = stateWithNewData.interactionToBeMerged,
      interactionToBeMerged = _stateWithNewData$int === undefined ? {} : _stateWithNewData$int;

  // merge state with saved filters

  var mergedState = (0, _visStateMerger.mergeFilters)(stateWithNewData, filterToBeMerged);
  // merge state with saved layers
  mergedState = (0, _visStateMerger.mergeLayers)(mergedState, layerToBeMerged);

  if (mergedState.layers.length === state.layers.length) {
    // no layer merged, find defaults
    mergedState = addDefaultLayers(mergedState, newDateEntries);
  }

  if (mergedState.splitMaps.length) {
    var newLayers = mergedState.layers.filter(function (l) {
      return l.config.dataId in newDateEntries;
    });
    // if map is splited, add new layers to splitMaps
    mergedState = (0, _extends14.default)({}, mergedState, {
      splitMaps: addNewLayersToSplitMap(mergedState.splitMaps, newLayers)
    });
  }

  // merge state with saved interactions
  mergedState = (0, _visStateMerger.mergeInteractions)(mergedState, interactionToBeMerged);

  // if no tooltips merged add default tooltips
  Object.keys(newDateEntries).forEach(function (dataId) {
    var tooltipFields = mergedState.interactionConfig.tooltip.config.fieldsToShow[dataId];
    if (!Array.isArray(tooltipFields) || !tooltipFields.length) {
      mergedState = addDefaultTooltips(mergedState, newDateEntries[dataId]);
    }
  });

  return updateAllLayerDomainData(mergedState, Object.keys(newDateEntries));
};
/* eslint-enable max-statements */

function generateLayerMetaForSplitViews(layer) {
  return {
    isAvailable: layer.config.isVisible,
    isVisible: layer.config.isVisible
  };
}

/**
 * This emthod will compute the default maps custom list
 * based on the current layers status
 * @param layers
 * @returns {[*,*]}
 */
function computeSplitMapLayers(layers) {
  var mapLayers = layers.reduce(function (newLayers, currentLayer) {
    return (0, _extends14.default)({}, newLayers, (0, _defineProperty3.default)({}, currentLayer.id, generateLayerMetaForSplitViews(currentLayer)));
  }, {});
  return [{
    layers: mapLayers
  }, {
    layers: mapLayers
  }];
}

/**
 * Remove an existing layers from custom map layer objects
 * @param state
 * @param layer
 * @returns {[*,*]} Maps of custom layer objects
 */
function removeLayerFromSplitMaps(state, layer) {
  return state.splitMaps.map(function (settings) {
    var layers = settings.layers;
    /* eslint-disable no-unused-vars */

    var _ = layers[layer.id],
        newLayers = (0, _objectWithoutProperties3.default)(layers, [layer.id]);
    /* eslint-enable no-unused-vars */

    return (0, _extends14.default)({}, settings, {
      layers: newLayers
    });
  });
}

/**
 * Add new layers to both existing maps
 * @param splitMaps
 * @param layers
 * @returns {[*,*]} new splitMaps
 */
function addNewLayersToSplitMap(splitMaps, layers) {
  var newLayers = Array.isArray(layers) ? layers : [layers];

  if (!splitMaps || !splitMaps.length || !newLayers.length) {
    return splitMaps;
  }

  // add new layer to both maps,
  //  don't override, if layer.id is already in splitMaps.settings.layers
  return splitMaps.map(function (settings) {
    return (0, _extends14.default)({}, settings, {
      layers: (0, _extends14.default)({}, settings.layers, newLayers.reduce(function (accu, newLayer) {
        return newLayer.config.isVisible ? (0, _extends14.default)({}, accu, (0, _defineProperty3.default)({}, newLayer.id, settings.layers[newLayer.id] ? settings.layers[newLayer.id] : generateLayerMetaForSplitViews(newLayer))) : accu;
      }, {}))
    });
  });
}

/**
 * Hide an existing layers from custom map layer objects
 * @param state
 * @param layer
 * @returns {[*,*]} Maps of custom layer objects
 */
function toggleLayerFromSplitMaps(state, layer) {
  return state.splitMaps.map(function (settings) {
    var layers = settings.layers;

    var newLayers = (0, _extends14.default)({}, layers, (0, _defineProperty3.default)({}, layer.id, generateLayerMetaForSplitViews(layer)));

    return (0, _extends14.default)({}, settings, {
      layers: newLayers
    });
  });
}

/**
 * When a user clicks on the specific map closing icon
 * the application will close the selected map
 * and will merge the remaining one with the global state
 * TODO: i think in the future this action should be called merge map layers with global settings
 * @param state
 * @param action
 * @returns {*}
 */
function closeSpecificMapAtIndex(state, action) {
  // retrieve layers meta data from the remaining map that we need to keep
  var indexToRetrieve = 1 - action.payload;

  var metaSettings = state.splitMaps[indexToRetrieve];
  if (!metaSettings || !metaSettings.layers) {
    // if we can't find the meta settings we simply clean up splitMaps and
    // keep global state as it is
    // but why does this ever happen?
    return (0, _extends14.default)({}, state, {
      splitMaps: []
    });
  }

  var layers = state.layers;

  // update layer visibility

  var newLayers = layers.map(function (layer) {
    return layer.updateLayerConfig({
      isVisible: metaSettings.layers[layer.id] ? metaSettings.layers[layer.id].isVisible : layer.config.isVisible
    });
  });

  // delete map
  return (0, _extends14.default)({}, state, {
    layers: newLayers,
    splitMaps: []
  });
}

// TODO: redo write handler to not use tasks
var loadFilesUpdater = exports.loadFilesUpdater = function loadFilesUpdater(state, action) {
  var files = action.files;

  var filesToLoad = files.map(function (fileBlob) {
    return {
      fileBlob: fileBlob,
      info: {
        id: (0, _utils.generateHashId)(4),
        label: fileBlob.name,
        size: fileBlob.size
      },
      handler: (0, _fileHandler.getFileHandler)(fileBlob)
    };
  });

  // reader -> parser -> augment -> receiveVisData
  var loadFileTasks = [_reactPalm.Task.all(filesToLoad.map(_tasks2.LOAD_FILE_TASK)).bimap(function (results) {
    var data = results.reduce(function (f, c) {
      return {
        // using concat here because the current datasets could be an array or a single item
        datasets: f.datasets.concat(c.datasets),
        // we need to deep merge this thing unless we find a better solution
        // this case will only happen if we allow to load multiple keplergl json files
        config: (0, _extends14.default)({}, f.config, c.config || {})
      };
    }, { datasets: [], config: {}, options: { centerMap: true } });
    return (0, _actions.addDataToMap)(data);
  }, function (error) {
    return (0, _visStateActions.loadFilesErr)(error);
  })];

  return (0, _reactPalm.withTask)((0, _extends14.default)({}, state, {
    fileLoading: true
  }), loadFileTasks);
};

var loadFilesErrUpdater = exports.loadFilesErrUpdater = function loadFilesErrUpdater(state, _ref7) {
  var error = _ref7.error;
  return (0, _extends14.default)({}, state, {
    fileLoading: false,
    fileLoadingErr: error
  });
};

/**
 * helper function to update All layer domain and layer data of state
 *
 * @param {object} state
 * @param {string} datasets
 * @returns {object} state
 */
function addDefaultLayers(state, datasets) {
  var defaultLayers = Object.values(datasets).reduce(function (accu, dataset) {
    return [].concat((0, _toConsumableArray3.default)(accu), (0, _toConsumableArray3.default)((0, _layerUtils.findDefaultLayer)(dataset, state.layerClasses) || []));
  }, []);
  return (0, _extends14.default)({}, state, {
    layers: [].concat((0, _toConsumableArray3.default)(state.layers), (0, _toConsumableArray3.default)(defaultLayers)),
    layerOrder: [].concat((0, _toConsumableArray3.default)(defaultLayers.map(function (_, i) {
      return state.layers.length + i;
    })), (0, _toConsumableArray3.default)(state.layerOrder))
  });
}

/**
 * helper function to find default tooltips
 *
 * @param {object} state
 * @param {object} dataset
 * @returns {object} state
 */
function addDefaultTooltips(state, dataset) {
  var tooltipFields = (0, _interactionUtils.findFieldsToShow)(dataset);

  return (0, _extends14.default)({}, state, {
    interactionConfig: (0, _extends14.default)({}, state.interactionConfig, {
      tooltip: (0, _extends14.default)({}, state.interactionConfig.tooltip, {
        config: {
          // find default fields to show in tooltip
          fieldsToShow: (0, _extends14.default)({}, state.interactionConfig.tooltip.config.fieldsToShow, tooltipFields)
        }
      })
    })
  });
}

/**
 * helper function to update layer domains for an array of datsets
 *
 * @param {object} state
 * @param {array | string} dataId
 * @param {object} newFilter - if is called by setFilter, the filter that has changed
 * @returns {object} state
 */
function updateAllLayerDomainData(state, dataId, newFilter) {
  var dataIds = typeof dataId === 'string' ? [dataId] : dataId;
  var newLayers = [];
  var newLayerDatas = [];

  state.layers.forEach(function (oldLayer, i) {
    if (oldLayer.config.dataId && dataIds.includes(oldLayer.config.dataId)) {
      // No need to recalculate layer domain if filter has fixed domain
      var newLayer = newFilter && newFilter.fixedDomain ? oldLayer : oldLayer.updateLayerDomain(state.datasets[oldLayer.config.dataId], newFilter);

      var _calculateLayerData5 = (0, _layerUtils.calculateLayerData)(newLayer, state, state.layerData[i]),
          layerData = _calculateLayerData5.layerData,
          layer = _calculateLayerData5.layer;

      newLayers.push(layer);
      newLayerDatas.push(layerData);
    } else {
      newLayers.push(oldLayer);
      newLayerDatas.push(state.layerData[i]);
    }
  });

  return (0, _extends14.default)({}, state, {
    layers: newLayers,
    layerData: newLayerDatas
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWR1Y2Vycy92aXMtc3RhdGUtdXBkYXRlcnMuanMiXSwibmFtZXMiOlsibGF5ZXJDb25maWdDaGFuZ2VVcGRhdGVyIiwibGF5ZXJUeXBlQ2hhbmdlVXBkYXRlciIsImxheWVyVmlzdWFsQ2hhbm5lbENoYW5nZVVwZGF0ZXIiLCJsYXllclZpc0NvbmZpZ0NoYW5nZVVwZGF0ZXIiLCJpbnRlcmFjdGlvbkNvbmZpZ0NoYW5nZVVwZGF0ZXIiLCJzZXRGaWx0ZXJVcGRhdGVyIiwiYWRkRGVmYXVsdExheWVycyIsImFkZERlZmF1bHRUb29sdGlwcyIsInVwZGF0ZUFsbExheWVyRG9tYWluRGF0YSIsIklOSVRJQUxfVklTX1NUQVRFIiwibGF5ZXJzIiwibGF5ZXJEYXRhIiwibGF5ZXJUb0JlTWVyZ2VkIiwibGF5ZXJPcmRlciIsImZpbHRlcnMiLCJmaWx0ZXJUb0JlTWVyZ2VkIiwiZGF0YXNldHMiLCJlZGl0aW5nRGF0YXNldCIsInVuZGVmaW5lZCIsImludGVyYWN0aW9uQ29uZmlnIiwiaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkIiwibGF5ZXJCbGVuZGluZyIsImhvdmVySW5mbyIsImNsaWNrZWQiLCJmaWxlTG9hZGluZyIsImZpbGVMb2FkaW5nRXJyIiwic3BsaXRNYXBzIiwibGF5ZXJDbGFzc2VzIiwiTGF5ZXJDbGFzc2VzIiwidXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhIiwic3RhdGUiLCJsYXllciIsImlkeCIsIm1hcCIsImx5ciIsImkiLCJkIiwiYWN0aW9uIiwib2xkTGF5ZXIiLCJmaW5kSW5kZXgiLCJsIiwiaWQiLCJwcm9wcyIsIk9iamVjdCIsImtleXMiLCJuZXdDb25maWciLCJuZXdMYXllciIsInVwZGF0ZUxheWVyQ29uZmlnIiwic2hvdWxkQ2FsY3VsYXRlTGF5ZXJEYXRhIiwib2xkTGF5ZXJEYXRhIiwic2FtZURhdGEiLCJuZXdTdGF0ZSIsInRvZ2dsZUxheWVyRnJvbVNwbGl0TWFwcyIsIm5ld1R5cGUiLCJvbGRJZCIsIkNvbnNvbGUiLCJlcnJvciIsImFzc2lnbkNvbmZpZ1RvTGF5ZXIiLCJjb25maWciLCJ2aXNDb25maWdTZXR0aW5ncyIsImRhdGFJZCIsImRhdGFzZXQiLCJ1cGRhdGVMYXllckRvbWFpbiIsInNldHRpbmdzIiwib2xkTGF5ZXJNYXAiLCJvdGhlckxheWVycyIsImNoYW5uZWwiLCJ1cGRhdGVMYXllclZpc3VhbENoYW5uZWwiLCJuZXdWaXNDb25maWciLCJ2aXNDb25maWciLCJlbmFibGVkIiwiZm9yRWFjaCIsImsiLCJwcm9wIiwidmFsdWUiLCJuZXdGaWx0ZXIiLCJmaWVsZHMiLCJhbGxEYXRhIiwiZmllbGRJZHgiLCJmIiwibmFtZSIsImZpZWxkIiwiZmlsdGVyUHJvcCIsImZyZWV6ZSIsInNldEZpbHRlclBsb3RVcGRhdGVyIiwibmV3UHJvcCIsInBsb3RUeXBlIiwiYWRkRmlsdGVyVXBkYXRlciIsInRvZ2dsZUZpbHRlckFuaW1hdGlvblVwZGF0ZXIiLCJpc0FuaW1hdGluZyIsInVwZGF0ZUFuaW1hdGlvblNwZWVkVXBkYXRlciIsInNwZWVkIiwiZW5sYXJnZUZpbHRlclVwZGF0ZXIiLCJpc0VubGFyZ2VkIiwiZW5sYXJnZWQiLCJyZW1vdmVGaWx0ZXJVcGRhdGVyIiwibmV3RmlsdGVycyIsInNsaWNlIiwibGVuZ3RoIiwiYWRkTGF5ZXJVcGRhdGVyIiwiZGVmYXVsdERhdGFzZXQiLCJMYXllciIsImlzVmlzaWJsZSIsImlzQ29uZmlnQWN0aXZlIiwiYWRkTmV3TGF5ZXJzVG9TcGxpdE1hcCIsInJlbW92ZUxheWVyVXBkYXRlciIsImxheWVyVG9SZW1vdmUiLCJuZXdNYXBzIiwicmVtb3ZlTGF5ZXJGcm9tU3BsaXRNYXBzIiwiZmlsdGVyIiwicGlkIiwiaXNMYXllckhvdmVyZWQiLCJyZW9yZGVyTGF5ZXJVcGRhdGVyIiwib3JkZXIiLCJyZW1vdmVEYXRhc2V0VXBkYXRlciIsImRhdGFzZXRLZXkiLCJrZXkiLCJuZXdEYXRhc2V0cyIsImluZGV4ZXMiLCJyZWR1Y2UiLCJsaXN0T2ZJbmRleGVzIiwiaW5kZXgiLCJwdXNoIiwiY3VycmVudFN0YXRlIiwiaW5kZXhDb3VudGVyIiwiY3VycmVudEluZGV4IiwidG9vbHRpcCIsImZpZWxkc1RvU2hvdyIsInVwZGF0ZUxheWVyQmxlbmRpbmdVcGRhdGVyIiwibW9kZSIsInNob3dEYXRhc2V0VGFibGVVcGRhdGVyIiwicmVzZXRNYXBDb25maWdVcGRhdGVyIiwiaW5pdGlhbFN0YXRlIiwicmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIiLCJwYXlsb2FkIiwidmlzU3RhdGUiLCJyZXNldFN0YXRlIiwibWVyZ2VkU3RhdGUiLCJsYXllckhvdmVyVXBkYXRlciIsImluZm8iLCJsYXllckNsaWNrVXBkYXRlciIsInBpY2tlZCIsIm1hcENsaWNrVXBkYXRlciIsInRvZ2dsZVNwbGl0TWFwVXBkYXRlciIsImNvbXB1dGVTcGxpdE1hcExheWVycyIsImNsb3NlU3BlY2lmaWNNYXBBdEluZGV4Iiwic2V0VmlzaWJsZUxheWVyc0Zvck1hcFVwZGF0ZXIiLCJtYXBJbmRleCIsImxheWVySWRzIiwibmV3TGF5ZXJzIiwiY3VycmVudExheWVycyIsImluY2x1ZGVzIiwidG9nZ2xlTGF5ZXJGb3JNYXBVcGRhdGVyIiwibWFwU2V0dGluZ3MiLCJsYXllcklkIiwibmV3U3BsaXRNYXBzIiwidXBkYXRlVmlzRGF0YVVwZGF0ZXIiLCJBcnJheSIsImlzQXJyYXkiLCJuZXdEYXRlRW50cmllcyIsImFjY3UiLCJkYXRhIiwic3RhdGVXaXRoTmV3RGF0YSIsInRvb2x0aXBGaWVsZHMiLCJnZW5lcmF0ZUxheWVyTWV0YUZvclNwbGl0Vmlld3MiLCJpc0F2YWlsYWJsZSIsIm1hcExheWVycyIsImN1cnJlbnRMYXllciIsIl8iLCJpbmRleFRvUmV0cmlldmUiLCJtZXRhU2V0dGluZ3MiLCJsb2FkRmlsZXNVcGRhdGVyIiwiZmlsZXMiLCJmaWxlc1RvTG9hZCIsImZpbGVCbG9iIiwibGFiZWwiLCJzaXplIiwiaGFuZGxlciIsImxvYWRGaWxlVGFza3MiLCJUYXNrIiwiYWxsIiwiTE9BRF9GSUxFX1RBU0siLCJiaW1hcCIsInJlc3VsdHMiLCJjIiwiY29uY2F0Iiwib3B0aW9ucyIsImNlbnRlck1hcCIsImxvYWRGaWxlc0VyclVwZGF0ZXIiLCJkZWZhdWx0TGF5ZXJzIiwidmFsdWVzIiwiZGF0YUlkcyIsIm5ld0xheWVyRGF0YXMiLCJmaXhlZERvbWFpbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUEySGdCQSx3QixHQUFBQSx3QjtRQTRCQUMsc0IsR0FBQUEsc0I7UUE4Q0FDLCtCLEdBQUFBLCtCO1FBaUJBQywyQixHQUFBQSwyQjtRQTRCQUMsOEIsR0FBQUEsOEI7UUF1QkFDLGdCLEdBQUFBLGdCO1FBc3NCQUMsZ0IsR0FBQUEsZ0I7UUEwQkFDLGtCLEdBQUFBLGtCO1FBNkJBQyx3QixHQUFBQSx3Qjs7QUFsL0JoQjs7QUFDQTs7QUFDQTs7QUFHQTs7QUFHQTs7QUFDQTs7QUFHQTs7QUFDQTs7QUFFQTs7QUFPQTs7QUFFQTs7QUFLQTs7QUFFQTs7QUFPQTs7OztBQUVBO0FBQ0E7OztBQXJDQTtBQXNDQTs7QUEvQkE7OztBQUpBO0FBM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQThDTyxJQUFNQyxnREFBb0I7QUFDL0I7QUFDQUMsVUFBUSxFQUZ1QjtBQUcvQkMsYUFBVyxFQUhvQjtBQUkvQkMsbUJBQWlCLEVBSmM7QUFLL0JDLGNBQVksRUFMbUI7O0FBTy9CO0FBQ0FDLFdBQVMsRUFSc0I7QUFTL0JDLG9CQUFrQixFQVRhOztBQVcvQjtBQUNBQyxZQUFVLEVBWnFCO0FBYS9CQyxrQkFBZ0JDLFNBYmU7O0FBZS9CQyxxQkFBbUIsOENBZlk7QUFnQi9CQyx5QkFBdUJGLFNBaEJROztBQWtCL0JHLGlCQUFlLFFBbEJnQjtBQW1CL0JDLGFBQVdKLFNBbkJvQjtBQW9CL0JLLFdBQVNMLFNBcEJzQjs7QUFzQi9CTSxlQUFhLEtBdEJrQjtBQXVCL0JD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VixDQUFlcEYsUUFBZjtBQUNBMEosb0JBQWN0RSxJQUFkLENBQW1CNUYsTUFBTW5CLFNBQU4sQ0FBZ0J3QixDQUFoQixDQUFuQjtBQUNEO0FBQ0YsR0F2QkQ7O0FBeUJBLHFDQUNLTCxLQURMO0FBRUVwQixZQUFRMkksU0FGVjtBQUdFMUksZUFBV3FMO0FBSGI7QUFLRCIsImZpbGUiOiJ2aXMtc3RhdGUtdXBkYXRlcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTggVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge2NvbnNvbGUgYXMgQ29uc29sZX0gZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5pbXBvcnQge1Rhc2ssIHdpdGhUYXNrfSBmcm9tICdyZWFjdC1wYWxtJztcbmltcG9ydCB7ZGlzYWJsZVN0YWNrQ2FwdHVyaW5nfSBmcm9tICdyZWFjdC1wYWxtL3Rhc2tzJztcblxuLy8gVGFza3NcbmltcG9ydCB7TE9BRF9GSUxFX1RBU0t9IGZyb20gJ3Rhc2tzL3Rhc2tzJztcblxuLy8gQWN0aW9uc1xuaW1wb3J0IHtsb2FkRmlsZXNFcnJ9IGZyb20gJ2FjdGlvbnMvdmlzLXN0YXRlLWFjdGlvbnMnO1xuaW1wb3J0IHthZGREYXRhVG9NYXB9IGZyb20gJ2FjdGlvbnMnO1xuXG4vLyBVdGlsc1xuaW1wb3J0IHtnZXREZWZhdWx0SW50ZXJhY3Rpb259IGZyb20gJ3V0aWxzL2ludGVyYWN0aW9uLXV0aWxzJztcbmltcG9ydCB7Z2VuZXJhdGVIYXNoSWR9IGZyb20gJ3V0aWxzL3V0aWxzJztcbmltcG9ydCB7ZmluZEZpZWxkc1RvU2hvd30gZnJvbSAndXRpbHMvaW50ZXJhY3Rpb24tdXRpbHMnO1xuaW1wb3J0IHtcbiAgZ2V0RGVmYXVsdEZpbHRlcixcbiAgZ2V0RmlsdGVyUHJvcHMsXG4gIGdldEZpbHRlclBsb3QsXG4gIGdldERlZmF1bHRGaWx0ZXJQbG90VHlwZSxcbiAgZmlsdGVyRGF0YVxufSBmcm9tICd1dGlscy9maWx0ZXItdXRpbHMnO1xuaW1wb3J0IHtjcmVhdGVOZXdEYXRhRW50cnl9IGZyb20gJ3V0aWxzL2RhdGFzZXQtdXRpbHMnO1xuXG5pbXBvcnQge1xuICBmaW5kRGVmYXVsdExheWVyLFxuICBjYWxjdWxhdGVMYXllckRhdGFcbn0gZnJvbSAndXRpbHMvbGF5ZXItdXRpbHMvbGF5ZXItdXRpbHMnO1xuXG5pbXBvcnQge2dldEZpbGVIYW5kbGVyfSBmcm9tICdwcm9jZXNzb3JzL2ZpbGUtaGFuZGxlcic7XG5cbmltcG9ydCB7XG4gIG1lcmdlRmlsdGVycyxcbiAgbWVyZ2VMYXllcnMsXG4gIG1lcmdlSW50ZXJhY3Rpb25zLFxuICBtZXJnZUxheWVyQmxlbmRpbmdcbn0gZnJvbSAnLi92aXMtc3RhdGUtbWVyZ2VyJztcblxuaW1wb3J0IHtMYXllckNsYXNzZXMsIExheWVyfSBmcm9tICdsYXllcnMnO1xuXG4vLyByZWFjdC1wYWxtXG4vLyBkaXNhYmxlIGNhcHR1cmUgZXhjZXB0aW9uIGZvciByZWFjdC1wYWxtIGNhbGwgdG8gd2l0aFRhc2tzXG5kaXNhYmxlU3RhY2tDYXB0dXJpbmcoKTtcblxuZXhwb3J0IGNvbnN0IElOSVRJQUxfVklTX1NUQVRFID0ge1xuICAvLyBsYXllcnNcbiAgbGF5ZXJzOiBbXSxcbiAgbGF5ZXJEYXRhOiBbXSxcbiAgbGF5ZXJUb0JlTWVyZ2VkOiBbXSxcbiAgbGF5ZXJPcmRlcjogW10sXG5cbiAgLy8gZmlsdGVyc1xuICBmaWx0ZXJzOiBbXSxcbiAgZmlsdGVyVG9CZU1lcmdlZDogW10sXG5cbiAgLy8gYSBjb2xsZWN0aW9uIG9mIG11bHRpcGxlIGRhdGFzZXRcbiAgZGF0YXNldHM6IHt9LFxuICBlZGl0aW5nRGF0YXNldDogdW5kZWZpbmVkLFxuXG4gIGludGVyYWN0aW9uQ29uZmlnOiBnZXREZWZhdWx0SW50ZXJhY3Rpb24oKSxcbiAgaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkOiB1bmRlZmluZWQsXG5cbiAgbGF5ZXJCbGVuZGluZzogJ25vcm1hbCcsXG4gIGhvdmVySW5mbzogdW5kZWZpbmVkLFxuICBjbGlja2VkOiB1bmRlZmluZWQsXG5cbiAgZmlsZUxvYWRpbmc6IGZhbHNlLFxuICBmaWxlTG9hZGluZ0VycjogbnVsbCxcblxuICAvLyB0aGlzIGlzIHVzZWQgd2hlbiB1c2VyIHNwbGl0IG1hcHNcbiAgc3BsaXRNYXBzOiBbXG4gICAgLy8gdGhpcyB3aWxsIGNvbnRhaW4gYSBsaXN0IG9mIG9iamVjdHMgdG9cbiAgICAvLyBkZXNjcmliZSB0aGUgc3RhdGUgb2YgbGF5ZXIgYXZhaWxhYmlsaXR5IGFuZCB2aXNpYmlsaXR5IGZvciBlYWNoIG1hcFxuICAgIC8vIFtcbiAgICAvLyAgIHtcbiAgICAvLyAgICAgbGF5ZXJzOiB7XG4gICAgLy8gICAgICAgbGF5ZXJfaWQ6IHtcbiAgICAvLyAgICAgICAgIGlzQXZhaWxhYmxlOiB0cnVlfGZhbHNlICMgdGhpcyBpcyBkcml2ZW4gYnkgdGhlIGxlZnQgaGFuZCBwYW5lbFxuICAgIC8vICAgICAgICAgaXNWaXNpYmxlOiB0cnVlfGZhbHNlXG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gICB9XG4gICAgLy8gXVxuICBdLFxuXG4gIC8vIGRlZmF1bHRzIGxheWVyIGNsYXNzZXNcbiAgbGF5ZXJDbGFzc2VzOiBMYXllckNsYXNzZXNcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShzdGF0ZSwge2xheWVyRGF0YSwgbGF5ZXIsIGlkeH0pIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnM6IHN0YXRlLmxheWVycy5tYXAoKGx5ciwgaSkgPT4gKGkgPT09IGlkeCA/IGxheWVyIDogbHlyKSksXG4gICAgbGF5ZXJEYXRhOiBsYXllckRhdGFcbiAgICAgID8gc3RhdGUubGF5ZXJEYXRhLm1hcCgoZCwgaSkgPT4gKGkgPT09IGlkeCA/IGxheWVyRGF0YSA6IGQpKVxuICAgICAgOiBzdGF0ZS5sYXllckRhdGFcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxsZWQgdG8gdXBkYXRlIGxheWVyIGJhc2UgY29uZmlnOiBkYXRhSWQsIGxhYmVsLCBjb2x1bW4sIGlzVmlzaWJsZVxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxheWVyQ29uZmlnQ2hhbmdlVXBkYXRlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIGNvbnN0IHtvbGRMYXllcn0gPSBhY3Rpb247XG4gIGNvbnN0IGlkeCA9IHN0YXRlLmxheWVycy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBvbGRMYXllci5pZCk7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMoYWN0aW9uLm5ld0NvbmZpZyk7XG5cbiAgY29uc3QgbmV3TGF5ZXIgPSBvbGRMYXllci51cGRhdGVMYXllckNvbmZpZyhhY3Rpb24ubmV3Q29uZmlnKTtcbiAgaWYgKG5ld0xheWVyLnNob3VsZENhbGN1bGF0ZUxheWVyRGF0YShwcm9wcykpIHtcbiAgICBjb25zdCBvbGRMYXllckRhdGEgPSBzdGF0ZS5sYXllckRhdGFbaWR4XTtcbiAgICBjb25zdCB7bGF5ZXJEYXRhLCBsYXllcn0gPSBjYWxjdWxhdGVMYXllckRhdGEoXG4gICAgICBuZXdMYXllcixcbiAgICAgIHN0YXRlLFxuICAgICAgb2xkTGF5ZXJEYXRhLFxuICAgICAge3NhbWVEYXRhOiB0cnVlfVxuICAgICk7XG4gICAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShzdGF0ZSwge2xheWVyRGF0YSwgbGF5ZXIsIGlkeH0pO1xuICB9XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgc3BsaXRNYXBzOlxuICAgICAgJ2lzVmlzaWJsZScgaW4gYWN0aW9uLm5ld0NvbmZpZ1xuICAgICAgICA/IHRvZ2dsZUxheWVyRnJvbVNwbGl0TWFwcyhzdGF0ZSwgbmV3TGF5ZXIpXG4gICAgICAgIDogc3RhdGUuc3BsaXRNYXBzXG4gIH07XG5cbiAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShuZXdTdGF0ZSwge2xheWVyOiBuZXdMYXllciwgaWR4fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXllclR5cGVDaGFuZ2VVcGRhdGVyKHN0YXRlLCBhY3Rpb24pIHtcbiAgY29uc3Qge29sZExheWVyLCBuZXdUeXBlfSA9IGFjdGlvbjtcbiAgY29uc3Qgb2xkSWQgPSBvbGRMYXllci5pZDtcbiAgY29uc3QgaWR4ID0gc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IG9sZElkKTtcblxuICBpZiAoIXN0YXRlLmxheWVyQ2xhc3Nlc1tuZXdUeXBlXSkge1xuICAgIENvbnNvbGUuZXJyb3IoYCR7bmV3VHlwZX0gaXMgbm90IGEgdmFsaWQgbGF5ZXIgdHlwZWApO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8vIGdldCBhIG1pbnQgbGF5ZXIsIHdpdGggbmV3IGlkIGFuZCB0eXBlXG4gIC8vIGJlY2F1c2UgZGVjay5nbCB1c2VzIGlkIHRvIG1hdGNoIGJldHdlZW4gbmV3IGFuZCBvbGQgbGF5ZXIuXG4gIC8vIElmIHR5cGUgaGFzIGNoYW5nZWQgYnV0IGlkIGlzIHRoZSBzYW1lLCBpdCB3aWxsIGJyZWFrXG4gIGNvbnN0IG5ld0xheWVyID0gbmV3IHN0YXRlLmxheWVyQ2xhc3Nlc1tuZXdUeXBlXSgpO1xuXG4gIG5ld0xheWVyLmFzc2lnbkNvbmZpZ1RvTGF5ZXIob2xkTGF5ZXIuY29uZmlnLCBvbGRMYXllci52aXNDb25maWdTZXR0aW5ncyk7XG5cbiAgaWYgKG5ld0xheWVyLmNvbmZpZy5kYXRhSWQpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gc3RhdGUuZGF0YXNldHNbbmV3TGF5ZXIuY29uZmlnLmRhdGFJZF07XG4gICAgbmV3TGF5ZXIudXBkYXRlTGF5ZXJEb21haW4oZGF0YXNldCk7XG4gIH1cblxuICBjb25zdCB7bGF5ZXJEYXRhLCBsYXllcn0gPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHN0YXRlKTtcblxuICBsZXQgbmV3U3RhdGUgPSBzdGF0ZTtcblxuICAvLyB1cGRhdGUgc3BsaXRNYXAgbGF5ZXIgaWRcbiAgaWYgKHN0YXRlLnNwbGl0TWFwcykge1xuICAgIG5ld1N0YXRlID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBzcGxpdE1hcHM6IHN0YXRlLnNwbGl0TWFwcy5tYXAoc2V0dGluZ3MgPT4ge1xuICAgICAgICBjb25zdCB7W29sZElkXTogb2xkTGF5ZXJNYXAsIC4uLm90aGVyTGF5ZXJzfSA9IHNldHRpbmdzLmxheWVycztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgICBsYXllcnM6IHtcbiAgICAgICAgICAgIC4uLm90aGVyTGF5ZXJzLFxuICAgICAgICAgICAgW2xheWVyLmlkXTogb2xkTGF5ZXJNYXBcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKG5ld1N0YXRlLCB7bGF5ZXJEYXRhLCBsYXllciwgaWR4fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXllclZpc3VhbENoYW5uZWxDaGFuZ2VVcGRhdGVyKHN0YXRlLCBhY3Rpb24pIHtcbiAgY29uc3Qge29sZExheWVyLCBuZXdDb25maWcsIGNoYW5uZWx9ID0gYWN0aW9uO1xuICBjb25zdCBkYXRhc2V0ID0gc3RhdGUuZGF0YXNldHNbb2xkTGF5ZXIuY29uZmlnLmRhdGFJZF07XG5cbiAgY29uc3QgaWR4ID0gc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IG9sZExheWVyLmlkKTtcbiAgY29uc3QgbmV3TGF5ZXIgPSBvbGRMYXllci51cGRhdGVMYXllckNvbmZpZyhuZXdDb25maWcpO1xuXG4gIG5ld0xheWVyLnVwZGF0ZUxheWVyVmlzdWFsQ2hhbm5lbChkYXRhc2V0LCBjaGFubmVsKTtcblxuICBjb25zdCBvbGRMYXllckRhdGEgPSBzdGF0ZS5sYXllckRhdGFbaWR4XTtcbiAgY29uc3Qge2xheWVyRGF0YSwgbGF5ZXJ9ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKG5ld0xheWVyLCBzdGF0ZSwgb2xkTGF5ZXJEYXRhLCB7XG4gICAgc2FtZURhdGE6IHRydWVcbiAgfSk7XG5cbiAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShzdGF0ZSwge2xheWVyRGF0YSwgbGF5ZXIsIGlkeH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJWaXNDb25maWdDaGFuZ2VVcGRhdGVyKHN0YXRlLCBhY3Rpb24pIHtcbiAgY29uc3Qge29sZExheWVyfSA9IGFjdGlvbjtcbiAgY29uc3QgaWR4ID0gc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IG9sZExheWVyLmlkKTtcbiAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyhhY3Rpb24ubmV3VmlzQ29uZmlnKTtcblxuICBjb25zdCBuZXdWaXNDb25maWcgPSB7XG4gICAgLi4ub2xkTGF5ZXIuY29uZmlnLnZpc0NvbmZpZyxcbiAgICAuLi5hY3Rpb24ubmV3VmlzQ29uZmlnXG4gIH07XG5cbiAgY29uc3QgbmV3TGF5ZXIgPSBvbGRMYXllci51cGRhdGVMYXllckNvbmZpZyh7dmlzQ29uZmlnOiBuZXdWaXNDb25maWd9KTtcblxuICBpZiAobmV3TGF5ZXIuc2hvdWxkQ2FsY3VsYXRlTGF5ZXJEYXRhKHByb3BzKSkge1xuICAgIGNvbnN0IG9sZExheWVyRGF0YSA9IHN0YXRlLmxheWVyRGF0YVtpZHhdO1xuICAgIGNvbnN0IHtsYXllckRhdGEsIGxheWVyfSA9IGNhbGN1bGF0ZUxheWVyRGF0YShcbiAgICAgIG5ld0xheWVyLFxuICAgICAgc3RhdGUsXG4gICAgICBvbGRMYXllckRhdGEsXG4gICAgICB7c2FtZURhdGE6IHRydWV9XG4gICAgKTtcbiAgICByZXR1cm4gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKHN0YXRlLCB7bGF5ZXJEYXRhLCBsYXllciwgaWR4fSk7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKHN0YXRlLCB7bGF5ZXI6IG5ld0xheWVyLCBpZHh9KTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJhY3Rpb25Db25maWdDaGFuZ2VVcGRhdGVyKHN0YXRlLCBhY3Rpb24pIHtcbiAgY29uc3Qge2NvbmZpZ30gPSBhY3Rpb247XG5cbiAgY29uc3QgaW50ZXJhY3Rpb25Db25maWcgPSB7XG4gICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Db25maWcsXG4gICAgLi4ue1tjb25maWcuaWRdOiBjb25maWd9XG4gIH07XG5cbiAgaWYgKGNvbmZpZy5lbmFibGVkICYmICFzdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZ1tjb25maWcuaWRdLmVuYWJsZWQpIHtcbiAgICAvLyBvbmx5IGVuYWJsZSBvbmUgaW50ZXJhY3Rpb24gYXQgYSB0aW1lXG4gICAgT2JqZWN0LmtleXMoaW50ZXJhY3Rpb25Db25maWcpLmZvckVhY2goayA9PiB7XG4gICAgICBpZiAoayAhPT0gY29uZmlnLmlkKSB7XG4gICAgICAgIGludGVyYWN0aW9uQ29uZmlnW2tdID0gey4uLmludGVyYWN0aW9uQ29uZmlnW2tdLCBlbmFibGVkOiBmYWxzZX07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGludGVyYWN0aW9uQ29uZmlnXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWx0ZXJVcGRhdGVyKHN0YXRlLCBhY3Rpb24pIHtcbiAgY29uc3Qge2lkeCwgcHJvcCwgdmFsdWV9ID0gYWN0aW9uO1xuICBsZXQgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgbGV0IG5ld0ZpbHRlciA9IHtcbiAgICAuLi5zdGF0ZS5maWx0ZXJzW2lkeF0sXG4gICAgW3Byb3BdOiB2YWx1ZVxuICB9O1xuXG4gIGNvbnN0IHtkYXRhSWR9ID0gbmV3RmlsdGVyO1xuICBpZiAoIWRhdGFJZCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCB7ZmllbGRzLCBhbGxEYXRhfSA9IHN0YXRlLmRhdGFzZXRzW2RhdGFJZF07XG5cbiAgc3dpdGNoIChwcm9wKSB7XG4gICAgY2FzZSAnZGF0YUlkJzpcbiAgICAgIC8vIGlmIHRyeWluZyB0byB1cGRhdGUgZmlsdGVyIGRhdGFJZC4gY3JlYXRlIGFuIGVtcHR5IG5ldyBmaWx0ZXJcbiAgICAgIG5ld0ZpbHRlciA9IGdldERlZmF1bHRGaWx0ZXIoZGF0YUlkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbmFtZSc6XG4gICAgICAvLyBmaW5kIHRoZSBmaWVsZFxuICAgICAgY29uc3QgZmllbGRJZHggPSBmaWVsZHMuZmluZEluZGV4KGYgPT4gZi5uYW1lID09PSB2YWx1ZSk7XG4gICAgICBsZXQgZmllbGQgPSBmaWVsZHNbZmllbGRJZHhdO1xuXG4gICAgICBpZiAoIWZpZWxkLmZpbHRlclByb3ApIHtcbiAgICAgICAgLy8gZ2V0IGZpbHRlciBkb21haW4gZnJvbSBmaWVsZFxuICAgICAgICAvLyBzYXZlIGZpbHRlclByb3BzOiB7ZG9tYWluLCBzdGVwcywgdmFsdWV9IHRvIGZpZWxkLCBhdm9pZCByZWNhbGN1bGF0ZVxuICAgICAgICBmaWVsZCA9IHtcbiAgICAgICAgICAuLi5maWVsZCxcbiAgICAgICAgICBmaWx0ZXJQcm9wOiBnZXRGaWx0ZXJQcm9wcyhhbGxEYXRhLCBmaWVsZClcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbmV3RmlsdGVyID0ge1xuICAgICAgICAuLi5uZXdGaWx0ZXIsXG4gICAgICAgIC4uLmZpZWxkLmZpbHRlclByb3AsXG4gICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgIC8vIGNhbid0IGVkaXQgZGF0YUlkIG9uY2UgbmFtZSBpcyBzZWxlY3RlZFxuICAgICAgICBmcmVlemU6IHRydWUsXG4gICAgICAgIGZpZWxkSWR4XG4gICAgICB9O1xuXG4gICAgICBuZXdTdGF0ZSA9IHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGRhdGFzZXRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZGF0YXNldHMsXG4gICAgICAgICAgW2RhdGFJZF06IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLmRhdGFzZXRzW2RhdGFJZF0sXG4gICAgICAgICAgICBmaWVsZHM6IGZpZWxkcy5tYXAoKGQsIGkpID0+IChpID09PSBmaWVsZElkeCA/IGZpZWxkIDogZCkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmFsdWUnOlxuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIHNhdmUgbmV3IGZpbHRlcnMgdG8gbmV3U3RhdGVcbiAgbmV3U3RhdGUgPSB7XG4gICAgLi4ubmV3U3RhdGUsXG4gICAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5tYXAoKGYsIGkpID0+IChpID09PSBpZHggPyBuZXdGaWx0ZXIgOiBmKSlcbiAgfTtcblxuICAvLyBmaWx0ZXIgZGF0YVxuICBuZXdTdGF0ZSA9IHtcbiAgICAuLi5uZXdTdGF0ZSxcbiAgICBkYXRhc2V0czoge1xuICAgICAgLi4ubmV3U3RhdGUuZGF0YXNldHMsXG4gICAgICBbZGF0YUlkXToge1xuICAgICAgICAuLi5uZXdTdGF0ZS5kYXRhc2V0c1tkYXRhSWRdLFxuICAgICAgICAuLi5maWx0ZXJEYXRhKGFsbERhdGEsIGRhdGFJZCwgbmV3U3RhdGUuZmlsdGVycylcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgbmV3U3RhdGUgPSB1cGRhdGVBbGxMYXllckRvbWFpbkRhdGEobmV3U3RhdGUsIGRhdGFJZCwgbmV3RmlsdGVyKTtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbmV4cG9ydCBjb25zdCBzZXRGaWx0ZXJQbG90VXBkYXRlciA9IChzdGF0ZSwge2lkeCwgbmV3UHJvcH0pID0+IHtcbiAgbGV0IG5ld0ZpbHRlciA9IHsuLi5zdGF0ZS5maWx0ZXJzW2lkeF0sIC4uLm5ld1Byb3B9O1xuICBjb25zdCBwcm9wID0gT2JqZWN0LmtleXMobmV3UHJvcClbMF07XG4gIGlmIChwcm9wID09PSAneUF4aXMnKSB7XG4gICAgY29uc3QgcGxvdFR5cGUgPSBnZXREZWZhdWx0RmlsdGVyUGxvdFR5cGUobmV3RmlsdGVyKTtcblxuICAgIGlmIChwbG90VHlwZSkge1xuICAgICAgbmV3RmlsdGVyID0ge1xuICAgICAgICAuLi5uZXdGaWx0ZXIsXG4gICAgICAgIC4uLmdldEZpbHRlclBsb3QoXG4gICAgICAgICAgey4uLm5ld0ZpbHRlciwgcGxvdFR5cGV9LFxuICAgICAgICAgIHN0YXRlLmRhdGFzZXRzW25ld0ZpbHRlci5kYXRhSWRdLmFsbERhdGFcbiAgICAgICAgKSxcbiAgICAgICAgcGxvdFR5cGVcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcCgoZiwgaSkgPT4gKGkgPT09IGlkeCA/IG5ld0ZpbHRlciA6IGYpKVxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGFkZEZpbHRlclVwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT5cbiAgIWFjdGlvbi5kYXRhSWRcbiAgICA/IHN0YXRlXG4gICAgOiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBmaWx0ZXJzOiBbLi4uc3RhdGUuZmlsdGVycywgZ2V0RGVmYXVsdEZpbHRlcihhY3Rpb24uZGF0YUlkKV1cbiAgICAgIH07XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVGaWx0ZXJBbmltYXRpb25VcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+ICh7XG4gIC4uLnN0YXRlLFxuICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcChcbiAgICAoZiwgaSkgPT4gKGkgPT09IGFjdGlvbi5pZHggPyB7Li4uZiwgaXNBbmltYXRpbmc6ICFmLmlzQW5pbWF0aW5nfSA6IGYpXG4gIClcbn0pO1xuXG5leHBvcnQgY29uc3QgdXBkYXRlQW5pbWF0aW9uU3BlZWRVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+ICh7XG4gIC4uLnN0YXRlLFxuICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcChcbiAgICAoZiwgaSkgPT4gKGkgPT09IGFjdGlvbi5pZHggPyB7Li4uZiwgc3BlZWQ6IGFjdGlvbi5zcGVlZH0gOiBmKVxuICApXG59KTtcblxuZXhwb3J0IGNvbnN0IGVubGFyZ2VGaWx0ZXJVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgY29uc3QgaXNFbmxhcmdlZCA9IHN0YXRlLmZpbHRlcnNbYWN0aW9uLmlkeF0uZW5sYXJnZWQ7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcCgoZiwgaSkgPT4ge1xuICAgICAgZi5lbmxhcmdlZCA9ICFpc0VubGFyZ2VkICYmIGkgPT09IGFjdGlvbi5pZHg7XG4gICAgICByZXR1cm4gZjtcbiAgICB9KVxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHJlbW92ZUZpbHRlclVwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBjb25zdCB7aWR4fSA9IGFjdGlvbjtcbiAgY29uc3Qge2RhdGFJZH0gPSBzdGF0ZS5maWx0ZXJzW2lkeF07XG5cbiAgY29uc3QgbmV3RmlsdGVycyA9IFtcbiAgICAuLi5zdGF0ZS5maWx0ZXJzLnNsaWNlKDAsIGlkeCksXG4gICAgLi4uc3RhdGUuZmlsdGVycy5zbGljZShpZHggKyAxLCBzdGF0ZS5maWx0ZXJzLmxlbmd0aClcbiAgXTtcblxuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBkYXRhc2V0czoge1xuICAgICAgLi4uc3RhdGUuZGF0YXNldHMsXG4gICAgICBbZGF0YUlkXToge1xuICAgICAgICAuLi5zdGF0ZS5kYXRhc2V0c1tkYXRhSWRdLFxuICAgICAgICAuLi5maWx0ZXJEYXRhKHN0YXRlLmRhdGFzZXRzW2RhdGFJZF0uYWxsRGF0YSwgZGF0YUlkLCBuZXdGaWx0ZXJzKVxuICAgICAgfVxuICAgIH0sXG4gICAgZmlsdGVyczogbmV3RmlsdGVyc1xuICB9O1xuXG4gIHJldHVybiB1cGRhdGVBbGxMYXllckRvbWFpbkRhdGEobmV3U3RhdGUsIGRhdGFJZCk7XG59O1xuXG5leHBvcnQgY29uc3QgYWRkTGF5ZXJVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgY29uc3QgZGVmYXVsdERhdGFzZXQgPSBPYmplY3Qua2V5cyhzdGF0ZS5kYXRhc2V0cylbMF07XG4gIGNvbnN0IG5ld0xheWVyID0gbmV3IExheWVyKHtcbiAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgaXNDb25maWdBY3RpdmU6IHRydWUsXG4gICAgZGF0YUlkOiBkZWZhdWx0RGF0YXNldCxcbiAgICAuLi5hY3Rpb24ucHJvcHNcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnM6IFsuLi5zdGF0ZS5sYXllcnMsIG5ld0xheWVyXSxcbiAgICBsYXllckRhdGE6IFsuLi5zdGF0ZS5sYXllckRhdGEsIHt9XSxcbiAgICBsYXllck9yZGVyOiBbLi4uc3RhdGUubGF5ZXJPcmRlciwgc3RhdGUubGF5ZXJPcmRlci5sZW5ndGhdLFxuICAgIHNwbGl0TWFwczogYWRkTmV3TGF5ZXJzVG9TcGxpdE1hcChzdGF0ZS5zcGxpdE1hcHMsIG5ld0xheWVyKVxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHJlbW92ZUxheWVyVXBkYXRlciA9IChzdGF0ZSwge2lkeH0pID0+IHtcbiAgY29uc3Qge2xheWVycywgbGF5ZXJEYXRhLCBjbGlja2VkLCBob3ZlckluZm99ID0gc3RhdGU7XG4gIGNvbnN0IGxheWVyVG9SZW1vdmUgPSBzdGF0ZS5sYXllcnNbaWR4XTtcbiAgY29uc3QgbmV3TWFwcyA9IHJlbW92ZUxheWVyRnJvbVNwbGl0TWFwcyhzdGF0ZSwgbGF5ZXJUb1JlbW92ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnM6IFsuLi5sYXllcnMuc2xpY2UoMCwgaWR4KSwgLi4ubGF5ZXJzLnNsaWNlKGlkeCArIDEsIGxheWVycy5sZW5ndGgpXSxcbiAgICBsYXllckRhdGE6IFtcbiAgICAgIC4uLmxheWVyRGF0YS5zbGljZSgwLCBpZHgpLFxuICAgICAgLi4ubGF5ZXJEYXRhLnNsaWNlKGlkeCArIDEsIGxheWVyRGF0YS5sZW5ndGgpXG4gICAgXSxcbiAgICBsYXllck9yZGVyOiBzdGF0ZS5sYXllck9yZGVyXG4gICAgICAuZmlsdGVyKGkgPT4gaSAhPT0gaWR4KVxuICAgICAgLm1hcChwaWQgPT4gKHBpZCA+IGlkeCA/IHBpZCAtIDEgOiBwaWQpKSxcbiAgICBjbGlja2VkOiBsYXllclRvUmVtb3ZlLmlzTGF5ZXJIb3ZlcmVkKGNsaWNrZWQpID8gdW5kZWZpbmVkIDogY2xpY2tlZCxcbiAgICBob3ZlckluZm86IGxheWVyVG9SZW1vdmUuaXNMYXllckhvdmVyZWQoaG92ZXJJbmZvKSA/IHVuZGVmaW5lZCA6IGhvdmVySW5mbyxcbiAgICBzcGxpdE1hcHM6IG5ld01hcHNcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCByZW9yZGVyTGF5ZXJVcGRhdGVyID0gKHN0YXRlLCB7b3JkZXJ9KSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgbGF5ZXJPcmRlcjogb3JkZXJcbn0pO1xuXG5leHBvcnQgY29uc3QgcmVtb3ZlRGF0YXNldFVwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAvLyBleHRyYWN0IGRhdGFzZXQga2V5XG4gIGNvbnN0IHtrZXk6IGRhdGFzZXRLZXl9ID0gYWN0aW9uO1xuICBjb25zdCB7ZGF0YXNldHN9ID0gc3RhdGU7XG5cbiAgLy8gY2hlY2sgaWYgZGF0YXNldCBpcyBwcmVzZW50XG4gIGlmICghZGF0YXNldHNbZGF0YXNldEtleV0pIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICBjb25zdCB7XG4gICAgbGF5ZXJzLFxuICAgIGRhdGFzZXRzOiB7W2RhdGFzZXRLZXldOiBkYXRhc2V0LCAuLi5uZXdEYXRhc2V0c31cbiAgfSA9IHN0YXRlO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgY29uc3QgaW5kZXhlcyA9IGxheWVycy5yZWR1Y2UoKGxpc3RPZkluZGV4ZXMsIGxheWVyLCBpbmRleCkgPT4ge1xuICAgIGlmIChsYXllci5jb25maWcuZGF0YUlkID09PSBkYXRhc2V0S2V5KSB7XG4gICAgICBsaXN0T2ZJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdE9mSW5kZXhlcztcbiAgfSwgW10pO1xuXG4gIC8vIHJlbW92ZSBsYXllcnMgYW5kIGRhdGFzZXRzXG4gIGNvbnN0IHtuZXdTdGF0ZX0gPSBpbmRleGVzLnJlZHVjZShcbiAgICAoe25ld1N0YXRlOiBjdXJyZW50U3RhdGUsIGluZGV4Q291bnRlcn0sIGlkeCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gaWR4IC0gaW5kZXhDb3VudGVyO1xuICAgICAgY3VycmVudFN0YXRlID0gcmVtb3ZlTGF5ZXJVcGRhdGVyKGN1cnJlbnRTdGF0ZSwge2lkeDogY3VycmVudEluZGV4fSk7XG4gICAgICBpbmRleENvdW50ZXIrKztcbiAgICAgIHJldHVybiB7bmV3U3RhdGU6IGN1cnJlbnRTdGF0ZSwgaW5kZXhDb3VudGVyfTtcbiAgICB9LFxuICAgIHtuZXdTdGF0ZTogey4uLnN0YXRlLCBkYXRhc2V0czogbmV3RGF0YXNldHN9LCBpbmRleENvdW50ZXI6IDB9XG4gICk7XG5cbiAgLy8gcmVtb3ZlIGZpbHRlcnNcbiAgY29uc3QgZmlsdGVycyA9IHN0YXRlLmZpbHRlcnMuZmlsdGVyKGZpbHRlciA9PiBmaWx0ZXIuZGF0YUlkICE9PSBkYXRhc2V0S2V5KTtcblxuICAvLyB1cGRhdGUgaW50ZXJhY3Rpb25Db25maWdcbiAgbGV0IHtpbnRlcmFjdGlvbkNvbmZpZ30gPSBzdGF0ZTtcbiAgY29uc3Qge3Rvb2x0aXB9ID0gaW50ZXJhY3Rpb25Db25maWc7XG4gIGlmICh0b29sdGlwKSB7XG4gICAgY29uc3Qge2NvbmZpZ30gPSB0b29sdGlwO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgY29uc3Qge1tkYXRhc2V0S2V5XTogZmllbGRzLCAuLi5maWVsZHNUb1Nob3d9ID0gY29uZmlnLmZpZWxkc1RvU2hvdztcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgaW50ZXJhY3Rpb25Db25maWcgPSB7XG4gICAgICAuLi5pbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAgIHRvb2x0aXA6IHsuLi50b29sdGlwLCBjb25maWc6IHsuLi5jb25maWcsIGZpZWxkc1RvU2hvd319XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7Li4ubmV3U3RhdGUsIGZpbHRlcnMsIGludGVyYWN0aW9uQ29uZmlnfTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVMYXllckJsZW5kaW5nVXBkYXRlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgbGF5ZXJCbGVuZGluZzogYWN0aW9uLm1vZGVcbn0pO1xuXG5leHBvcnQgY29uc3Qgc2hvd0RhdGFzZXRUYWJsZVVwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVkaXRpbmdEYXRhc2V0OiBhY3Rpb24uZGF0YUlkXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcmVzZXRNYXBDb25maWdVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+ICh7XG4gIC4uLklOSVRJQUxfVklTX1NUQVRFLFxuICAuLi5zdGF0ZS5pbml0aWFsU3RhdGUsXG4gIGluaXRpYWxTdGF0ZTogc3RhdGUuaW5pdGlhbFN0YXRlXG59KTtcblxuLyoqXG4gKiBMb2FkcyBjdXN0b20gY29uZmlndXJhdGlvbiBpbnRvIHN0YXRlXG4gKiBAcGFyYW0gc3RhdGVcbiAqIEBwYXJhbSBhY3Rpb25cbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgY29uc3QgcmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBpZiAoIWFjdGlvbi5wYXlsb2FkLnZpc1N0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGZpbHRlcnMsXG4gICAgbGF5ZXJzLFxuICAgIGludGVyYWN0aW9uQ29uZmlnLFxuICAgIGxheWVyQmxlbmRpbmcsXG4gICAgc3BsaXRNYXBzXG4gIH0gPSBhY3Rpb24ucGF5bG9hZC52aXNTdGF0ZTtcblxuICAvLyBhbHdheXMgcmVzZXQgY29uZmlnIHdoZW4gcmVjZWl2ZSBhIG5ldyBjb25maWdcbiAgY29uc3QgcmVzZXRTdGF0ZSA9IHJlc2V0TWFwQ29uZmlnVXBkYXRlcihzdGF0ZSk7XG4gIGxldCBtZXJnZWRTdGF0ZSA9IHtcbiAgICAuLi5yZXNldFN0YXRlLFxuICAgIHNwbGl0TWFwczogc3BsaXRNYXBzIHx8IFtdIC8vIG1hcHMgZG9lc24ndCByZXF1aXJlIGFueSBsb2dpY1xuICB9O1xuXG4gIG1lcmdlZFN0YXRlID0gbWVyZ2VGaWx0ZXJzKG1lcmdlZFN0YXRlLCBmaWx0ZXJzKTtcbiAgbWVyZ2VkU3RhdGUgPSBtZXJnZUxheWVycyhtZXJnZWRTdGF0ZSwgbGF5ZXJzKTtcbiAgbWVyZ2VkU3RhdGUgPSBtZXJnZUludGVyYWN0aW9ucyhtZXJnZWRTdGF0ZSwgaW50ZXJhY3Rpb25Db25maWcpO1xuICBtZXJnZWRTdGF0ZSA9IG1lcmdlTGF5ZXJCbGVuZGluZyhtZXJnZWRTdGF0ZSwgbGF5ZXJCbGVuZGluZyk7XG5cbiAgcmV0dXJuIG1lcmdlZFN0YXRlO1xufTtcblxuZXhwb3J0IGNvbnN0IGxheWVySG92ZXJVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+ICh7XG4gIC4uLnN0YXRlLFxuICBob3ZlckluZm86IGFjdGlvbi5pbmZvXG59KTtcblxuZXhwb3J0IGNvbnN0IGxheWVyQ2xpY2tVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+ICh7XG4gIC4uLnN0YXRlLFxuICBjbGlja2VkOiBhY3Rpb24uaW5mbyAmJiBhY3Rpb24uaW5mby5waWNrZWQgPyBhY3Rpb24uaW5mbyA6IG51bGxcbn0pO1xuXG5leHBvcnQgY29uc3QgbWFwQ2xpY2tVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+ICh7XG4gIC4uLnN0YXRlLFxuICBjbGlja2VkOiBudWxsXG59KTtcblxuZXhwb3J0IGNvbnN0IHRvZ2dsZVNwbGl0TWFwVXBkYXRlciA9IChzdGF0ZSwgYWN0aW9uKSA9PlxuICBzdGF0ZS5zcGxpdE1hcHMgJiYgc3RhdGUuc3BsaXRNYXBzLmxlbmd0aCA9PT0gMFxuICAgID8ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgLy8gbWF5YmUgd2Ugc2hvdWxkIHVzZSBhbiBhcnJheSB0byBzdG9yZSBzdGF0ZSBmb3IgYSBzaW5nbGUgbWFwIGFzIHdlbGxcbiAgICAgICAgLy8gaWYgY3VycmVudCBtYXBzIGxlbmd0aCBpcyBlcXVhbCB0byAwIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGFib3V0IHRvIHNwbGl0IHRoZSB2aWV3XG4gICAgICAgIHNwbGl0TWFwczogY29tcHV0ZVNwbGl0TWFwTGF5ZXJzKHN0YXRlLmxheWVycylcbiAgICAgIH1cbiAgICA6IGNsb3NlU3BlY2lmaWNNYXBBdEluZGV4KHN0YXRlLCBhY3Rpb24pO1xuXG4vKipcbiAqIFRoaXMgaXMgdHJpZ2dlcmVkIHdoZW4gdmlldyBpcyBzcGxpdCBpbnRvIG11bHRpcGxlIG1hcHMuXG4gKiBJdCB3aWxsIG9ubHkgdXBkYXRlIGxheWVycyB0aGF0IGJlbG9uZyB0byB0aGUgbWFwIGxheWVyIGRyb3Bkb3duXG4gKiB0aGUgdXNlciBpcyBpbnRlcmFjdGluZyB3aXRcbiAqIEBwYXJhbSBzdGF0ZVxuICogQHBhcmFtIGFjdGlvblxuICovXG5leHBvcnQgY29uc3Qgc2V0VmlzaWJsZUxheWVyc0Zvck1hcFVwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBjb25zdCB7bWFwSW5kZXgsIGxheWVySWRzfSA9IGFjdGlvbjtcbiAgaWYgKCFsYXllcklkcykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHtzcGxpdE1hcHMgPSBbXX0gPSBzdGF0ZTtcblxuICBpZiAoc3BsaXRNYXBzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIHdlIHNob3VsZCBuZXZlciBnZXQgaW50byB0aGlzIHN0YXRlXG4gICAgLy8gYmVjYXVzZSB0aGlzIGFjdGlvbiBzaG91bGQgb25seSBiZSB0cmlnZ2VyZWRcbiAgICAvLyB3aGVuIG1hcCB2aWV3IGlzIHNwbGl0XG4gICAgLy8gYnV0IHNvbWV0aGluZyBtYXkgaGF2ZSBoYXBwZW5lZFxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8vIG5lZWQgdG8gY2hlY2sgaWYgbWFwcyBpcyBwb3B1bGF0ZWQgb3RoZXJ3aXNlIHdpbGwgY3JlYXRlXG4gIGNvbnN0IHtbbWFwSW5kZXhdOiBtYXAgPSB7fX0gPSBzcGxpdE1hcHM7XG5cbiAgY29uc3QgbGF5ZXJzID0gbWFwLmxheWVycyB8fCBbXTtcblxuICAvLyB3ZSBzZXQgdmlzaWJpbGl0eSB0byB0cnVlIGZvciBhbGwgbGF5ZXJzIGluY2x1ZGVkIGluIG91ciBpbnB1dCBsaXN0XG4gIGNvbnN0IG5ld0xheWVycyA9IChPYmplY3Qua2V5cyhsYXllcnMpIHx8IFtdKS5yZWR1Y2UoKGN1cnJlbnRMYXllcnMsIGlkeCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jdXJyZW50TGF5ZXJzLFxuICAgICAgW2lkeF06IHtcbiAgICAgICAgLi4ubGF5ZXJzW2lkeF0sXG4gICAgICAgIGlzVmlzaWJsZTogbGF5ZXJJZHMuaW5jbHVkZXMoaWR4KVxuICAgICAgfVxuICAgIH07XG4gIH0sIHt9KTtcblxuICBjb25zdCBuZXdNYXBzID0gWy4uLnNwbGl0TWFwc107XG5cbiAgbmV3TWFwc1ttYXBJbmRleF0gPSB7XG4gICAgLi4uc3BsaXRNYXBzW21hcEluZGV4XSxcbiAgICBsYXllcnM6IG5ld0xheWVyc1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgc3BsaXRNYXBzOiBuZXdNYXBzXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdG9nZ2xlTGF5ZXJGb3JNYXBVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgaWYgKCFzdGF0ZS5zcGxpdE1hcHNbYWN0aW9uLm1hcEluZGV4XSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IG1hcFNldHRpbmdzID0gc3RhdGUuc3BsaXRNYXBzW2FjdGlvbi5tYXBJbmRleF07XG4gIGNvbnN0IHtsYXllcnN9ID0gbWFwU2V0dGluZ3M7XG4gIGlmICghbGF5ZXJzIHx8ICFsYXllcnNbYWN0aW9uLmxheWVySWRdKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3QgbGF5ZXIgPSBsYXllcnNbYWN0aW9uLmxheWVySWRdO1xuXG4gIGNvbnN0IG5ld0xheWVyID0ge1xuICAgIC4uLmxheWVyLFxuICAgIGlzVmlzaWJsZTogIWxheWVyLmlzVmlzaWJsZVxuICB9O1xuXG4gIGNvbnN0IG5ld0xheWVycyA9IHtcbiAgICAuLi5sYXllcnMsXG4gICAgW2FjdGlvbi5sYXllcklkXTogbmV3TGF5ZXJcbiAgfTtcblxuICAvLyBjb25zdCBzcGxpdE1hcHMgPSBzdGF0ZS5zcGxpdE1hcHM7XG4gIGNvbnN0IG5ld1NwbGl0TWFwcyA9IFsuLi5zdGF0ZS5zcGxpdE1hcHNdO1xuICBuZXdTcGxpdE1hcHNbYWN0aW9uLm1hcEluZGV4XSA9IHtcbiAgICAuLi5tYXBTZXR0aW5ncyxcbiAgICBsYXllcnM6IG5ld0xheWVyc1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgc3BsaXRNYXBzOiBuZXdTcGxpdE1hcHNcbiAgfTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG5leHBvcnQgY29uc3QgdXBkYXRlVmlzRGF0YVVwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAvLyBkYXRhc2V0cyBjYW4gYmUgYSBzaW5nbGUgZGF0YSBlbnRyaWVzIG9yIGFuIGFycmF5IG9mIG11bHRpcGxlIGRhdGEgZW50cmllc1xuICBjb25zdCBkYXRhc2V0cyA9IEFycmF5LmlzQXJyYXkoYWN0aW9uLmRhdGFzZXRzKVxuICAgID8gYWN0aW9uLmRhdGFzZXRzXG4gICAgOiBbYWN0aW9uLmRhdGFzZXRzXTtcblxuICBpZiAoYWN0aW9uLmNvbmZpZykge1xuICAgIC8vIGFwcGx5IGNvbmZpZyBpZiBwYXNzZWQgZnJvbSBhY3Rpb25cbiAgICBzdGF0ZSA9IHJlY2VpdmVNYXBDb25maWdVcGRhdGVyKHN0YXRlLCB7XG4gICAgICBwYXlsb2FkOiB7dmlzU3RhdGU6IGFjdGlvbi5jb25maWd9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBuZXdEYXRlRW50cmllcyA9IGRhdGFzZXRzLnJlZHVjZShcbiAgICAoYWNjdSwge2luZm8gPSB7fSwgZGF0YX0pID0+ICh7XG4gICAgICAuLi5hY2N1LFxuICAgICAgLi4uKGNyZWF0ZU5ld0RhdGFFbnRyeSh7aW5mbywgZGF0YX0sIHN0YXRlLmRhdGFzZXRzKSB8fCB7fSlcbiAgICB9KSxcbiAgICB7fVxuICApO1xuXG4gIGlmICghT2JqZWN0LmtleXMobmV3RGF0ZUVudHJpZXMpLmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlV2l0aE5ld0RhdGEgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgZGF0YXNldHM6IHtcbiAgICAgIC4uLnN0YXRlLmRhdGFzZXRzLFxuICAgICAgLi4ubmV3RGF0ZUVudHJpZXNcbiAgICB9XG4gIH07XG5cbiAgLy8gcHJldmlvdXNseSBzYXZlZCBjb25maWcgYmVmb3JlIGRhdGEgbG9hZGVkXG4gIGNvbnN0IHtcbiAgICBmaWx0ZXJUb0JlTWVyZ2VkID0gW10sXG4gICAgbGF5ZXJUb0JlTWVyZ2VkID0gW10sXG4gICAgaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkID0ge31cbiAgfSA9IHN0YXRlV2l0aE5ld0RhdGE7XG5cbiAgLy8gbWVyZ2Ugc3RhdGUgd2l0aCBzYXZlZCBmaWx0ZXJzXG4gIGxldCBtZXJnZWRTdGF0ZSA9IG1lcmdlRmlsdGVycyhzdGF0ZVdpdGhOZXdEYXRhLCBmaWx0ZXJUb0JlTWVyZ2VkKTtcbiAgLy8gbWVyZ2Ugc3RhdGUgd2l0aCBzYXZlZCBsYXllcnNcbiAgbWVyZ2VkU3RhdGUgPSBtZXJnZUxheWVycyhtZXJnZWRTdGF0ZSwgbGF5ZXJUb0JlTWVyZ2VkKTtcblxuICBpZiAobWVyZ2VkU3RhdGUubGF5ZXJzLmxlbmd0aCA9PT0gc3RhdGUubGF5ZXJzLmxlbmd0aCkge1xuICAgIC8vIG5vIGxheWVyIG1lcmdlZCwgZmluZCBkZWZhdWx0c1xuICAgIG1lcmdlZFN0YXRlID0gYWRkRGVmYXVsdExheWVycyhtZXJnZWRTdGF0ZSwgbmV3RGF0ZUVudHJpZXMpO1xuICB9XG5cbiAgaWYgKG1lcmdlZFN0YXRlLnNwbGl0TWFwcy5sZW5ndGgpIHtcbiAgICBjb25zdCBuZXdMYXllcnMgPSBtZXJnZWRTdGF0ZS5sYXllcnMuZmlsdGVyKFxuICAgICAgbCA9PiBsLmNvbmZpZy5kYXRhSWQgaW4gbmV3RGF0ZUVudHJpZXNcbiAgICApO1xuICAgIC8vIGlmIG1hcCBpcyBzcGxpdGVkLCBhZGQgbmV3IGxheWVycyB0byBzcGxpdE1hcHNcbiAgICBtZXJnZWRTdGF0ZSA9IHtcbiAgICAgIC4uLm1lcmdlZFN0YXRlLFxuICAgICAgc3BsaXRNYXBzOiBhZGROZXdMYXllcnNUb1NwbGl0TWFwKG1lcmdlZFN0YXRlLnNwbGl0TWFwcywgbmV3TGF5ZXJzKVxuICAgIH07XG4gIH1cblxuICAvLyBtZXJnZSBzdGF0ZSB3aXRoIHNhdmVkIGludGVyYWN0aW9uc1xuICBtZXJnZWRTdGF0ZSA9IG1lcmdlSW50ZXJhY3Rpb25zKG1lcmdlZFN0YXRlLCBpbnRlcmFjdGlvblRvQmVNZXJnZWQpO1xuXG4gIC8vIGlmIG5vIHRvb2x0aXBzIG1lcmdlZCBhZGQgZGVmYXVsdCB0b29sdGlwc1xuICBPYmplY3Qua2V5cyhuZXdEYXRlRW50cmllcykuZm9yRWFjaChkYXRhSWQgPT4ge1xuICAgIGNvbnN0IHRvb2x0aXBGaWVsZHMgPVxuICAgICAgbWVyZ2VkU3RhdGUuaW50ZXJhY3Rpb25Db25maWcudG9vbHRpcC5jb25maWcuZmllbGRzVG9TaG93W2RhdGFJZF07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRvb2x0aXBGaWVsZHMpIHx8ICF0b29sdGlwRmllbGRzLmxlbmd0aCkge1xuICAgICAgbWVyZ2VkU3RhdGUgPSBhZGREZWZhdWx0VG9vbHRpcHMobWVyZ2VkU3RhdGUsIG5ld0RhdGVFbnRyaWVzW2RhdGFJZF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHVwZGF0ZUFsbExheWVyRG9tYWluRGF0YShtZXJnZWRTdGF0ZSwgT2JqZWN0LmtleXMobmV3RGF0ZUVudHJpZXMpKTtcbn07XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbmZ1bmN0aW9uIGdlbmVyYXRlTGF5ZXJNZXRhRm9yU3BsaXRWaWV3cyhsYXllcikge1xuICByZXR1cm4ge1xuICAgIGlzQXZhaWxhYmxlOiBsYXllci5jb25maWcuaXNWaXNpYmxlLFxuICAgIGlzVmlzaWJsZTogbGF5ZXIuY29uZmlnLmlzVmlzaWJsZVxuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZW10aG9kIHdpbGwgY29tcHV0ZSB0aGUgZGVmYXVsdCBtYXBzIGN1c3RvbSBsaXN0XG4gKiBiYXNlZCBvbiB0aGUgY3VycmVudCBsYXllcnMgc3RhdHVzXG4gKiBAcGFyYW0gbGF5ZXJzXG4gKiBAcmV0dXJucyB7WyosKl19XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTcGxpdE1hcExheWVycyhsYXllcnMpIHtcbiAgY29uc3QgbWFwTGF5ZXJzID0gbGF5ZXJzLnJlZHVjZShcbiAgICAobmV3TGF5ZXJzLCBjdXJyZW50TGF5ZXIpID0+ICh7XG4gICAgICAuLi5uZXdMYXllcnMsXG4gICAgICBbY3VycmVudExheWVyLmlkXTogZ2VuZXJhdGVMYXllck1ldGFGb3JTcGxpdFZpZXdzKGN1cnJlbnRMYXllcilcbiAgICB9KSxcbiAgICB7fVxuICApO1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGxheWVyczogbWFwTGF5ZXJzXG4gICAgfSxcbiAgICB7XG4gICAgICBsYXllcnM6IG1hcExheWVyc1xuICAgIH1cbiAgXTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYW4gZXhpc3RpbmcgbGF5ZXJzIGZyb20gY3VzdG9tIG1hcCBsYXllciBvYmplY3RzXG4gKiBAcGFyYW0gc3RhdGVcbiAqIEBwYXJhbSBsYXllclxuICogQHJldHVybnMge1sqLCpdfSBNYXBzIG9mIGN1c3RvbSBsYXllciBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxheWVyRnJvbVNwbGl0TWFwcyhzdGF0ZSwgbGF5ZXIpIHtcbiAgcmV0dXJuIHN0YXRlLnNwbGl0TWFwcy5tYXAoc2V0dGluZ3MgPT4ge1xuICAgIGNvbnN0IHtsYXllcnN9ID0gc2V0dGluZ3M7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICBjb25zdCB7W2xheWVyLmlkXTogXywgLi4ubmV3TGF5ZXJzfSA9IGxheWVycztcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNldHRpbmdzLFxuICAgICAgbGF5ZXJzOiBuZXdMYXllcnNcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiBBZGQgbmV3IGxheWVycyB0byBib3RoIGV4aXN0aW5nIG1hcHNcbiAqIEBwYXJhbSBzcGxpdE1hcHNcbiAqIEBwYXJhbSBsYXllcnNcbiAqIEByZXR1cm5zIHtbKiwqXX0gbmV3IHNwbGl0TWFwc1xuICovXG5mdW5jdGlvbiBhZGROZXdMYXllcnNUb1NwbGl0TWFwKHNwbGl0TWFwcywgbGF5ZXJzKSB7XG4gIGNvbnN0IG5ld0xheWVycyA9IEFycmF5LmlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdO1xuXG4gIGlmICghc3BsaXRNYXBzIHx8ICFzcGxpdE1hcHMubGVuZ3RoIHx8ICFuZXdMYXllcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHNwbGl0TWFwcztcbiAgfVxuXG4gIC8vIGFkZCBuZXcgbGF5ZXIgdG8gYm90aCBtYXBzLFxuICAvLyAgZG9uJ3Qgb3ZlcnJpZGUsIGlmIGxheWVyLmlkIGlzIGFscmVhZHkgaW4gc3BsaXRNYXBzLnNldHRpbmdzLmxheWVyc1xuICByZXR1cm4gc3BsaXRNYXBzLm1hcChzZXR0aW5ncyA9PiAoe1xuICAgIC4uLnNldHRpbmdzLFxuICAgIGxheWVyczoge1xuICAgICAgLi4uc2V0dGluZ3MubGF5ZXJzLFxuICAgICAgLi4ubmV3TGF5ZXJzLnJlZHVjZShcbiAgICAgICAgKGFjY3UsIG5ld0xheWVyKSA9PlxuICAgICAgICAgIG5ld0xheWVyLmNvbmZpZy5pc1Zpc2libGVcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgICAgICAgW25ld0xheWVyLmlkXTogc2V0dGluZ3MubGF5ZXJzW25ld0xheWVyLmlkXVxuICAgICAgICAgICAgICAgICAgPyBzZXR0aW5ncy5sYXllcnNbbmV3TGF5ZXIuaWRdXG4gICAgICAgICAgICAgICAgICA6IGdlbmVyYXRlTGF5ZXJNZXRhRm9yU3BsaXRWaWV3cyhuZXdMYXllcilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBhY2N1LFxuICAgICAgICB7fVxuICAgICAgKVxuICAgIH1cbiAgfSkpO1xufVxuXG4vKipcbiAqIEhpZGUgYW4gZXhpc3RpbmcgbGF5ZXJzIGZyb20gY3VzdG9tIG1hcCBsYXllciBvYmplY3RzXG4gKiBAcGFyYW0gc3RhdGVcbiAqIEBwYXJhbSBsYXllclxuICogQHJldHVybnMge1sqLCpdfSBNYXBzIG9mIGN1c3RvbSBsYXllciBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUxheWVyRnJvbVNwbGl0TWFwcyhzdGF0ZSwgbGF5ZXIpIHtcbiAgcmV0dXJuIHN0YXRlLnNwbGl0TWFwcy5tYXAoc2V0dGluZ3MgPT4ge1xuICAgIGNvbnN0IHtsYXllcnN9ID0gc2V0dGluZ3M7XG4gICAgY29uc3QgbmV3TGF5ZXJzID0ge1xuICAgICAgLi4ubGF5ZXJzLFxuICAgICAgW2xheWVyLmlkXTogZ2VuZXJhdGVMYXllck1ldGFGb3JTcGxpdFZpZXdzKGxheWVyKVxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2V0dGluZ3MsXG4gICAgICBsYXllcnM6IG5ld0xheWVyc1xuICAgIH07XG4gIH0pO1xufVxuXG4vKipcbiAqIFdoZW4gYSB1c2VyIGNsaWNrcyBvbiB0aGUgc3BlY2lmaWMgbWFwIGNsb3NpbmcgaWNvblxuICogdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2xvc2UgdGhlIHNlbGVjdGVkIG1hcFxuICogYW5kIHdpbGwgbWVyZ2UgdGhlIHJlbWFpbmluZyBvbmUgd2l0aCB0aGUgZ2xvYmFsIHN0YXRlXG4gKiBUT0RPOiBpIHRoaW5rIGluIHRoZSBmdXR1cmUgdGhpcyBhY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBtZXJnZSBtYXAgbGF5ZXJzIHdpdGggZ2xvYmFsIHNldHRpbmdzXG4gKiBAcGFyYW0gc3RhdGVcbiAqIEBwYXJhbSBhY3Rpb25cbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBjbG9zZVNwZWNpZmljTWFwQXRJbmRleChzdGF0ZSwgYWN0aW9uKSB7XG4gIC8vIHJldHJpZXZlIGxheWVycyBtZXRhIGRhdGEgZnJvbSB0aGUgcmVtYWluaW5nIG1hcCB0aGF0IHdlIG5lZWQgdG8ga2VlcFxuICBjb25zdCBpbmRleFRvUmV0cmlldmUgPSAxIC0gYWN0aW9uLnBheWxvYWQ7XG5cbiAgY29uc3QgbWV0YVNldHRpbmdzID0gc3RhdGUuc3BsaXRNYXBzW2luZGV4VG9SZXRyaWV2ZV07XG4gIGlmICghbWV0YVNldHRpbmdzIHx8ICFtZXRhU2V0dGluZ3MubGF5ZXJzKSB7XG4gICAgLy8gaWYgd2UgY2FuJ3QgZmluZCB0aGUgbWV0YSBzZXR0aW5ncyB3ZSBzaW1wbHkgY2xlYW4gdXAgc3BsaXRNYXBzIGFuZFxuICAgIC8vIGtlZXAgZ2xvYmFsIHN0YXRlIGFzIGl0IGlzXG4gICAgLy8gYnV0IHdoeSBkb2VzIHRoaXMgZXZlciBoYXBwZW4/XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgc3BsaXRNYXBzOiBbXVxuICAgIH07XG4gIH1cblxuICBjb25zdCB7bGF5ZXJzfSA9IHN0YXRlO1xuXG4gIC8vIHVwZGF0ZSBsYXllciB2aXNpYmlsaXR5XG4gIGNvbnN0IG5ld0xheWVycyA9IGxheWVycy5tYXAobGF5ZXIgPT5cbiAgICBsYXllci51cGRhdGVMYXllckNvbmZpZyh7XG4gICAgICBpc1Zpc2libGU6IG1ldGFTZXR0aW5ncy5sYXllcnNbbGF5ZXIuaWRdXG4gICAgICAgID8gbWV0YVNldHRpbmdzLmxheWVyc1tsYXllci5pZF0uaXNWaXNpYmxlXG4gICAgICAgIDogbGF5ZXIuY29uZmlnLmlzVmlzaWJsZVxuICAgIH0pXG4gICk7XG5cbiAgLy8gZGVsZXRlIG1hcFxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogbmV3TGF5ZXJzLFxuICAgIHNwbGl0TWFwczogW11cbiAgfTtcbn1cblxuLy8gVE9ETzogcmVkbyB3cml0ZSBoYW5kbGVyIHRvIG5vdCB1c2UgdGFza3NcbmV4cG9ydCBjb25zdCBsb2FkRmlsZXNVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgY29uc3Qge2ZpbGVzfSA9IGFjdGlvbjtcbiAgY29uc3QgZmlsZXNUb0xvYWQgPSBmaWxlcy5tYXAoZmlsZUJsb2IgPT4gKHtcbiAgICBmaWxlQmxvYixcbiAgICBpbmZvOiB7XG4gICAgICBpZDogZ2VuZXJhdGVIYXNoSWQoNCksXG4gICAgICBsYWJlbDogZmlsZUJsb2IubmFtZSxcbiAgICAgIHNpemU6IGZpbGVCbG9iLnNpemVcbiAgICB9LFxuICAgIGhhbmRsZXI6IGdldEZpbGVIYW5kbGVyKGZpbGVCbG9iKVxuICB9KSk7XG5cbiAgLy8gcmVhZGVyIC0+IHBhcnNlciAtPiBhdWdtZW50IC0+IHJlY2VpdmVWaXNEYXRhXG4gIGNvbnN0IGxvYWRGaWxlVGFza3MgPSBbXG4gICAgVGFzay5hbGwoZmlsZXNUb0xvYWQubWFwKExPQURfRklMRV9UQVNLKSkuYmltYXAoXG4gICAgICByZXN1bHRzID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlc3VsdHMucmVkdWNlKChmLCBjKSA9PiAoe1xuICAgICAgICAgIC8vIHVzaW5nIGNvbmNhdCBoZXJlIGJlY2F1c2UgdGhlIGN1cnJlbnQgZGF0YXNldHMgY291bGQgYmUgYW4gYXJyYXkgb3IgYSBzaW5nbGUgaXRlbVxuICAgICAgICAgIGRhdGFzZXRzOiBmLmRhdGFzZXRzLmNvbmNhdChjLmRhdGFzZXRzKSxcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGRlZXAgbWVyZ2UgdGhpcyB0aGluZyB1bmxlc3Mgd2UgZmluZCBhIGJldHRlciBzb2x1dGlvblxuICAgICAgICAgIC8vIHRoaXMgY2FzZSB3aWxsIG9ubHkgaGFwcGVuIGlmIHdlIGFsbG93IHRvIGxvYWQgbXVsdGlwbGUga2VwbGVyZ2wganNvbiBmaWxlc1xuICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgLi4uZi5jb25maWcsXG4gICAgICAgICAgICAuLi4oYy5jb25maWcgfHwge30pXG4gICAgICAgICAgfVxuICAgICAgICB9KSwge2RhdGFzZXRzOiBbXSwgY29uZmlnOiB7fSwgb3B0aW9uczoge2NlbnRlck1hcDogdHJ1ZX19KTtcbiAgICAgICAgcmV0dXJuIGFkZERhdGFUb01hcChkYXRhKTtcbiAgICAgIH0sXG4gICAgICBlcnJvciA9PiBsb2FkRmlsZXNFcnIoZXJyb3IpXG4gICAgKVxuICBdO1xuXG4gIHJldHVybiB3aXRoVGFzayhcbiAgICB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGZpbGVMb2FkaW5nOiB0cnVlXG4gICAgfSxcbiAgICBsb2FkRmlsZVRhc2tzXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgbG9hZEZpbGVzRXJyVXBkYXRlciA9IChzdGF0ZSwge2Vycm9yfSkgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGZpbGVMb2FkaW5nOiBmYWxzZSxcbiAgZmlsZUxvYWRpbmdFcnI6IGVycm9yXG59KTtcblxuLyoqXG4gKiBoZWxwZXIgZnVuY3Rpb24gdG8gdXBkYXRlIEFsbCBsYXllciBkb21haW4gYW5kIGxheWVyIGRhdGEgb2Ygc3RhdGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0c1xuICogQHJldHVybnMge29iamVjdH0gc3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZERlZmF1bHRMYXllcnMoc3RhdGUsIGRhdGFzZXRzKSB7XG4gIGNvbnN0IGRlZmF1bHRMYXllcnMgPSBPYmplY3QudmFsdWVzKGRhdGFzZXRzKS5yZWR1Y2UoXG4gICAgKGFjY3UsIGRhdGFzZXQpID0+IFtcbiAgICAgIC4uLmFjY3UsXG4gICAgICAuLi4oZmluZERlZmF1bHRMYXllcihkYXRhc2V0LCBzdGF0ZS5sYXllckNsYXNzZXMpIHx8IFtdKVxuICAgIF0sXG4gICAgW11cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnM6IFsuLi5zdGF0ZS5sYXllcnMsIC4uLmRlZmF1bHRMYXllcnNdLFxuICAgIGxheWVyT3JkZXI6IFtcbiAgICAgIC8vIHB1dCBuZXcgbGF5ZXJzIG9uIHRvcCBvZiBvbGQgb25lc1xuICAgICAgLi4uZGVmYXVsdExheWVycy5tYXAoKF8sIGkpID0+IHN0YXRlLmxheWVycy5sZW5ndGggKyBpKSxcbiAgICAgIC4uLnN0YXRlLmxheWVyT3JkZXJcbiAgICBdXG4gIH07XG59XG5cbi8qKlxuICogaGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgZGVmYXVsdCB0b29sdGlwc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtvYmplY3R9IGRhdGFzZXRcbiAqIEByZXR1cm5zIHtvYmplY3R9IHN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGREZWZhdWx0VG9vbHRpcHMoc3RhdGUsIGRhdGFzZXQpIHtcbiAgY29uc3QgdG9vbHRpcEZpZWxkcyA9IGZpbmRGaWVsZHNUb1Nob3coZGF0YXNldCk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBpbnRlcmFjdGlvbkNvbmZpZzoge1xuICAgICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Db25maWcsXG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIC4uLnN0YXRlLmludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAsXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgIC8vIGZpbmQgZGVmYXVsdCBmaWVsZHMgdG8gc2hvdyBpbiB0b29sdGlwXG4gICAgICAgICAgZmllbGRzVG9TaG93OiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZy50b29sdGlwLmNvbmZpZy5maWVsZHNUb1Nob3csXG4gICAgICAgICAgICAuLi50b29sdGlwRmllbGRzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIGhlbHBlciBmdW5jdGlvbiB0byB1cGRhdGUgbGF5ZXIgZG9tYWlucyBmb3IgYW4gYXJyYXkgb2YgZGF0c2V0c1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHthcnJheSB8IHN0cmluZ30gZGF0YUlkXG4gKiBAcGFyYW0ge29iamVjdH0gbmV3RmlsdGVyIC0gaWYgaXMgY2FsbGVkIGJ5IHNldEZpbHRlciwgdGhlIGZpbHRlciB0aGF0IGhhcyBjaGFuZ2VkXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBzdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhKHN0YXRlLCBkYXRhSWQsIG5ld0ZpbHRlcikge1xuICBjb25zdCBkYXRhSWRzID0gdHlwZW9mIGRhdGFJZCA9PT0gJ3N0cmluZycgPyBbZGF0YUlkXSA6IGRhdGFJZDtcbiAgY29uc3QgbmV3TGF5ZXJzID0gW107XG4gIGNvbnN0IG5ld0xheWVyRGF0YXMgPSBbXTtcblxuICBzdGF0ZS5sYXllcnMuZm9yRWFjaCgob2xkTGF5ZXIsIGkpID0+IHtcbiAgICBpZiAob2xkTGF5ZXIuY29uZmlnLmRhdGFJZCAmJiBkYXRhSWRzLmluY2x1ZGVzKG9sZExheWVyLmNvbmZpZy5kYXRhSWQpKSB7XG4gICAgICAvLyBObyBuZWVkIHRvIHJlY2FsY3VsYXRlIGxheWVyIGRvbWFpbiBpZiBmaWx0ZXIgaGFzIGZpeGVkIGRvbWFpblxuICAgICAgY29uc3QgbmV3TGF5ZXIgPVxuICAgICAgICBuZXdGaWx0ZXIgJiYgbmV3RmlsdGVyLmZpeGVkRG9tYWluXG4gICAgICAgICAgPyBvbGRMYXllclxuICAgICAgICAgIDogb2xkTGF5ZXIudXBkYXRlTGF5ZXJEb21haW4oXG4gICAgICAgICAgICAgIHN0YXRlLmRhdGFzZXRzW29sZExheWVyLmNvbmZpZy5kYXRhSWRdLFxuICAgICAgICAgICAgICBuZXdGaWx0ZXJcbiAgICAgICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHtsYXllckRhdGEsIGxheWVyfSA9IGNhbGN1bGF0ZUxheWVyRGF0YShcbiAgICAgICAgbmV3TGF5ZXIsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBzdGF0ZS5sYXllckRhdGFbaV1cbiAgICAgICk7XG5cbiAgICAgIG5ld0xheWVycy5wdXNoKGxheWVyKTtcbiAgICAgIG5ld0xheWVyRGF0YXMucHVzaChsYXllckRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdMYXllcnMucHVzaChvbGRMYXllcik7XG4gICAgICBuZXdMYXllckRhdGFzLnB1c2goc3RhdGUubGF5ZXJEYXRhW2ldKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBuZXdMYXllcnMsXG4gICAgbGF5ZXJEYXRhOiBuZXdMYXllckRhdGFzXG4gIH07XG59XG4iXX0=