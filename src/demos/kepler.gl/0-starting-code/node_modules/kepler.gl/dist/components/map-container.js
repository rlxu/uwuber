'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _extends3 = require('babel-runtime/helpers/extends');

var _extends4 = _interopRequireDefault(_extends3);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

exports.default = MapContainerFactory;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactMapGl = require('react-map-gl');

var _reactMapGl2 = _interopRequireDefault(_reactMapGl);

var _deck = require('deck.gl');

var _deck2 = _interopRequireDefault(_deck);

var _luma = require('luma.gl');

var _mapPopover = require('./map/map-popover');

var _mapPopover2 = _interopRequireDefault(_mapPopover);

var _mapControl = require('./map/map-control');

var _mapControl2 = _interopRequireDefault(_mapControl);

var _styledComponents = require('./common/styled-components');

var _mapboxUtils = require('../layers/mapbox-utils');

var _mapboxUtils2 = require('../utils/map-style-utils/mapbox-utils');

var _defaultSettings = require('../constants/default-settings');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// components
var MAP_STYLE = {
  container: {
    display: 'inline-block',
    position: 'relative'
  },
  top: {
    position: 'absolute', top: '0px', pointerEvents: 'none'
  }
};

// default-settings


// Overlay type
// Copyright (c) 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// libraries


var getGlConst = function getGlConst(d) {
  return _luma.GL[d];
};

var MAPBOXGL_STYLE_UPDATE = 'style.load';
MapContainerFactory.deps = [_mapPopover2.default, _mapControl2.default];

function MapContainerFactory(MapPopover, MapControl) {
  var _class, _temp;

  var MapContainer = (_temp = _class = function (_Component) {
    (0, _inherits3.default)(MapContainer, _Component);

    function MapContainer(props) {
      (0, _classCallCheck3.default)(this, MapContainer);

      var _this = (0, _possibleConstructorReturn3.default)(this, (MapContainer.__proto__ || Object.getPrototypeOf(MapContainer)).call(this, props));

      _this._onCloseMapPopover = function () {
        _this.props.visStateActions.onLayerClick(null);
      };

      _this._onLayerSetDomain = function (idx, colorDomain) {
        _this.props.visStateActions.layerConfigChange(_this.props.layers[idx], {
          colorDomain: colorDomain
        });
      };

      _this._onWebGLInitialized = function (gl) {
        // enable depth test for perspective mode
        if (_this.props.mapState.dragRotate) {
          gl.enable(gl.DEPTH_TEST);
          gl.depthFunc(gl.LEQUAL);
        } else {
          gl.disable(gl.DEPTH_TEST);
        }

        // allow Uint32 indices in building layer
        gl.getExtension('OES_element_index_uint');

        _this._togglelayerBlending(gl);

        _this.setState({ gl: gl });
      };

      _this._onMouseMove = function (evt) {
        var brush = _this.props.interactionConfig.brush;


        if (evt.nativeEvent && brush.enabled) {
          _this.setState({
            mousePosition: [evt.nativeEvent.offsetX, evt.nativeEvent.offsetY]
          });
        }
      };

      _this._handleMapToggleLayer = function (layerId) {
        var _this$props = _this.props,
            _this$props$index = _this$props.index,
            mapIndex = _this$props$index === undefined ? 0 : _this$props$index,
            visStateActions = _this$props.visStateActions;

        visStateActions.toggleLayerForMap(mapIndex, layerId);
      };

      _this._togglelayerBlending = function (gl) {
        var blending = _defaultSettings.LAYER_BLENDINGS[_this.props.layerBlending];
        var enable = blending.enable,
            blendFunc = blending.blendFunc,
            blendEquation = blending.blendEquation,
            blendFuncSeparate = blending.blendFuncSeparate,
            blendEquationSeparate = blending.blendEquationSeparate;


        if (enable) {
          gl.enable(_luma.GL.BLEND);
          if (blendFunc) {
            gl.blendFunc.apply(gl, (0, _toConsumableArray3.default)(blendFunc.map(getGlConst)));
            gl.blendEquation(_luma.GL[blendEquation]);
          } else {
            gl.blendFuncSeparate.apply(gl, (0, _toConsumableArray3.default)(blendFuncSeparate.map(getGlConst)));
            gl.blendEquationSeparate.apply(gl, (0, _toConsumableArray3.default)(blendEquationSeparate.map(getGlConst)));
          }
        } else {
          gl.disable(_luma.GL.BLEND);
        }
      };

      _this._renderLayer = function (overlays, idx) {
        var _this$props2 = _this.props,
            layers = _this$props2.layers,
            layerData = _this$props2.layerData,
            hoverInfo = _this$props2.hoverInfo,
            clicked = _this$props2.clicked,
            mapLayers = _this$props2.mapLayers,
            mapState = _this$props2.mapState,
            visStateActions = _this$props2.visStateActions,
            interactionConfig = _this$props2.interactionConfig;
        var mousePosition = _this.state.mousePosition;

        var layer = layers[idx];
        var data = layerData[idx];

        var layerInteraction = {
          onHover: visStateActions.onLayerHover,
          onClick: visStateActions.onLayerClick,
          mousePosition: mousePosition
        };

        var objectHovered = clicked || hoverInfo;
        var layerCallbacks = {
          onSetLayerDomain: function onSetLayerDomain(val) {
            return _this._onLayerSetDomain(idx, val);
          }
        };

        if (!_this._shouldRenderLayer(layer, data, mapLayers)) {
          return overlays;
        }

        var layerOverlay = [];

        // Layer is Layer class
        if (typeof layer.renderLayer === 'function') {
          layerOverlay = layer.renderLayer({
            data: data,
            idx: idx,
            layerInteraction: layerInteraction,
            objectHovered: objectHovered,
            mapState: mapState,
            interactionConfig: interactionConfig,
            layerCallbacks: layerCallbacks
          });
        }

        if (layerOverlay.length) {
          overlays = overlays.concat(layerOverlay);
        }
        return overlays;
      };

      _this.state = {
        reRenderKey: 0,
        gl: null,
        mousePosition: [0, 0]
      };
      _this.previousLayers = {
        // [layers.id]: mapboxLayerConfig
      };
      return _this;
    }

    (0, _createClass3.default)(MapContainer, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        if (this.props.mapState.dragRotate !== nextProps.mapState.dragRotate || this.props.layerBlending !== nextProps.layerBlending) {
          // increment rerender key to force gl reinitialize when
          // perspective or layer blending changed
          // TODO: layer blending can now be implemented per layer base
          this.setState({
            reRenderKey: this.state.reRenderKey + 1
          });
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps, prevState) {
        var _this2 = this;

        if (!this._map && this.refs.mapbox) {
          this._map = this.refs.mapbox.getMap();
          // bind mapboxgl event listener
          this._map.on(MAPBOXGL_STYLE_UPDATE, function () {
            // force refresh mapboxgl layers

            (0, _mapboxUtils.updateMapboxLayers)(_this2._map, _this2._renderMapboxLayers(), _this2.previousLayers, _this2.props.mapLayers, { force: true });

            if (typeof _this2.props.onMapStyleLoaded === 'function') {
              _this2.props.onMapStyleLoaded(_this2._map);
            }
          });

          this._map.on('render', function () {
            if (typeof _this2.props.onMapRender === 'function') {
              _this2.props.onMapRender(_this2._map);
            }
          });
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        // unbind mapboxgl event listener
        if (this._map) {
          this._map.off(MAPBOXGL_STYLE_UPDATE);
        }
      }

      /* component private functions */

      /* deck.gl doesn't support blendFuncSeparate yet
       * so we're applying the blending ourselves
      */

    }, {
      key: '_renderObjectLayerPopover',


      /* component render functions */

      /* eslint-disable complexity */
      value: function _renderObjectLayerPopover() {
        // TODO: move this into reducer so it can be tested
        var _props = this.props,
            mapState = _props.mapState,
            hoverInfo = _props.hoverInfo,
            clicked = _props.clicked,
            datasets = _props.datasets,
            interactionConfig = _props.interactionConfig,
            layers = _props.layers,
            mapLayers = _props.mapLayers;

        // if clicked something, ignore hover behavior

        var objectInfo = clicked || hoverInfo;
        if (!interactionConfig.tooltip.enabled || !objectInfo || !objectInfo.picked) {
          // nothing hovered
          return null;
        }

        var lngLat = objectInfo.lngLat,
            object = objectInfo.object,
            overlay = objectInfo.layer;

        // deckgl layer to kepler-gl layer

        var layer = layers[overlay.props.idx];

        if (!layer || !layer.config.isVisible || !object || !layer.getHoverData || mapLayers && !mapLayers[layer.id].isVisible) {
          // layer is not visible
          return null;
        }

        var dataId = layer.config.dataId;
        var _datasets$dataId = datasets[dataId],
            allData = _datasets$dataId.allData,
            fields = _datasets$dataId.fields;

        var data = layer.getHoverData(object, allData);

        // project lnglat to screen so that tooltip follows the object on zoom
        var viewport = overlay.context.viewport;

        var _ref = this._getHoverXY(viewport, lngLat) || objectInfo,
            x = _ref.x,
            y = _ref.y;

        var popoverProps = {
          data: data,
          fields: fields,
          fieldsToShow: interactionConfig.tooltip.config.fieldsToShow[dataId],
          layer: layer,
          isVisible: true,
          x: x,
          y: y,
          freezed: Boolean(clicked),
          onClose: this._onCloseMapPopover,
          mapState: mapState
        };

        return _react2.default.createElement(
          'div',
          null,
          _react2.default.createElement(MapPopover, popoverProps)
        );
      }

      /* eslint-enable complexity */

    }, {
      key: '_getHoverXY',
      value: function _getHoverXY(viewport, lngLat) {
        var screenCoord = !viewport || !lngLat ? null : viewport.project(lngLat);

        return screenCoord && { x: screenCoord[0], y: screenCoord[1] };
      }
    }, {
      key: '_shouldRenderLayer',
      value: function _shouldRenderLayer(layer, data, mapLayers) {
        var isAvailableAndVisible = !(mapLayers && mapLayers[layer.id]) || mapLayers[layer.id].isVisible;
        return layer.shouldRenderLayer(data) && isAvailableAndVisible;
      }
    }, {
      key: '_renderOverlay',
      value: function _renderOverlay() {
        var _props2 = this.props,
            mapState = _props2.mapState,
            layerData = _props2.layerData,
            layerOrder = _props2.layerOrder;


        var deckGlLayers = [];

        // wait until data is ready before render data layers
        if (layerData && layerData.length) {
          // last layer render first
          deckGlLayers = layerOrder.slice().reverse().reduce(this._renderLayer, []);
        }

        return _react2.default.createElement(_deck2.default, (0, _extends4.default)({}, mapState, {
          id: 'default-deckgl-overlay',
          layers: deckGlLayers,
          key: this.state.reRenderKey,
          onWebGLInitialized: this._onWebGLInitialized
        }));
      }
    }, {
      key: '_renderMapboxLayers',
      value: function _renderMapboxLayers() {
        var _props3 = this.props,
            layers = _props3.layers,
            layerData = _props3.layerData,
            layerOrder = _props3.layerOrder;


        return (0, _mapboxUtils.generateMapboxLayers)(layers, layerData, layerOrder);
      }
    }, {
      key: '_renderMapboxOverlays',
      value: function _renderMapboxOverlays() {
        if (this._map && this._map.isStyleLoaded()) {

          var mapboxLayers = this._renderMapboxLayers();

          (0, _mapboxUtils.updateMapboxLayers)(this._map, mapboxLayers, this.previousLayers, this.props.mapLayers);

          this.previousLayers = mapboxLayers.reduce(function (final, layer) {
            return (0, _extends4.default)({}, final, (0, _defineProperty3.default)({}, layer.id, layer.config));
          }, {});
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _props4 = this.props,
            mapState = _props4.mapState,
            mapStyle = _props4.mapStyle,
            mapStateActions = _props4.mapStateActions;
        var updateMap = mapStateActions.updateMap,
            onMapClick = mapStateActions.onMapClick;


        if (!mapStyle.bottomMapStyle) {
          // style not yet loaded
          return _react2.default.createElement('div', null);
        }

        var _props5 = this.props,
            mapLayers = _props5.mapLayers,
            layers = _props5.layers,
            datasets = _props5.datasets,
            mapboxApiAccessToken = _props5.mapboxApiAccessToken,
            mapControls = _props5.mapControls,
            toggleMapControl = _props5.toggleMapControl;


        var mapProps = (0, _extends4.default)({}, mapState, {
          preserveDrawingBuffer: true,
          mapboxApiAccessToken: mapboxApiAccessToken,
          onViewportChange: updateMap,
          transformRequest: _mapboxUtils2.transformRequest
        });

        return _react2.default.createElement(
          _styledComponents.StyledMapContainer,
          { style: MAP_STYLE.container, onMouseMove: this._onMouseMove },
          _react2.default.createElement(MapControl, {
            datasets: datasets,
            dragRotate: mapState.dragRotate,
            isSplit: mapState.isSplit,
            isExport: this.props.isExport,
            layers: layers,
            mapIndex: this.props.index,
            mapLayers: mapLayers,
            mapControls: mapControls,
            scale: mapState.scale || 1,
            top: 0,
            onTogglePerspective: mapStateActions.togglePerspective,
            onToggleSplitMap: mapStateActions.toggleSplitMap,
            onMapToggleLayer: this._handleMapToggleLayer,
            onToggleFullScreen: mapStateActions.toggleFullScreen,
            onToggleMapControl: toggleMapControl
          }),
          _react2.default.createElement(
            this.props.MapComponent,
            (0, _extends4.default)({}, mapProps, {
              key: 'bottom',
              ref: 'mapbox',
              mapStyle: mapStyle.bottomMapStyle,
              onClick: onMapClick
            }),
            this._renderOverlay(),
            this._renderMapboxOverlays()
          ),
          mapStyle.topMapStyle && _react2.default.createElement(
            'div',
            { style: MAP_STYLE.top },
            _react2.default.createElement(this.props.MapComponent, (0, _extends4.default)({}, mapProps, {
              key: 'top',
              mapStyle: mapStyle.topMapStyle
            }))
          ),
          this._renderObjectLayerPopover()
        );
      }
    }]);
    return MapContainer;
  }(_react.Component), _class.propTypes = {
    // required
    datasets: _propTypes2.default.object,
    interactionConfig: _propTypes2.default.object.isRequired,
    layerBlending: _propTypes2.default.string.isRequired,
    layerOrder: _propTypes2.default.arrayOf(_propTypes2.default.any).isRequired,
    layerData: _propTypes2.default.arrayOf(_propTypes2.default.any).isRequired,
    layers: _propTypes2.default.arrayOf(_propTypes2.default.any).isRequired,
    mapState: _propTypes2.default.object.isRequired,
    mapStyle: _propTypes2.default.object.isRequired,
    mapControls: _propTypes2.default.object.isRequired,
    mapboxApiAccessToken: _propTypes2.default.string.isRequired,
    toggleMapControl: _propTypes2.default.func.isRequired,
    visStateActions: _propTypes2.default.object.isRequired,
    mapStateActions: _propTypes2.default.object.isRequired,

    // optional
    isExport: _propTypes2.default.bool,
    clicked: _propTypes2.default.object,
    hoverInfo: _propTypes2.default.object,
    mapLayers: _propTypes2.default.object,
    onMapToggleLayer: _propTypes2.default.func,
    onMapStyleLoaded: _propTypes2.default.func,
    onMapRender: _propTypes2.default.func
  }, _class.defaultProps = {
    MapComponent: _reactMapGl2.default
  }, _temp);


  return MapContainer;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL21hcC1jb250YWluZXIuanMiXSwibmFtZXMiOlsiTWFwQ29udGFpbmVyRmFjdG9yeSIsIk1BUF9TVFlMRSIsImNvbnRhaW5lciIsImRpc3BsYXkiLCJwb3NpdGlvbiIsInRvcCIsInBvaW50ZXJFdmVudHMiLCJnZXRHbENvbnN0IiwiR0wiLCJkIiwiTUFQQk9YR0xfU1RZTEVfVVBEQVRFIiwiZGVwcyIsIk1hcFBvcG92ZXJGYWN0b3J5IiwiTWFwQ29udHJvbEZhY3RvcnkiLCJNYXBQb3BvdmVyIiwiTWFwQ29udHJvbCIsIk1hcENvbnRhaW5lciIsInByb3BzIiwiX29uQ2xvc2VNYXBQb3BvdmVyIiwidmlzU3RhdGVBY3Rpb25zIiwib25MYXllckNsaWNrIiwiX29uTGF5ZXJTZXREb21haW4iLCJpZHgiLCJjb2xvckRvbWFpbiIsImxheWVyQ29uZmlnQ2hhbmdlIiwibGF5ZXJzIiwiX29uV2ViR0xJbml0aWFsaXplZCIsIm1hcFN0YXRlIiwiZHJhZ1JvdGF0ZSIsImdsIiwiZW5hYmxlIiwiREVQVEhfVEVTVCIsImRlcHRoRnVuYyIsIkxFUVVBTCIsImRpc2FibGUiLCJnZXRFeHRlbnNpb24iLCJfdG9nZ2xlbGF5ZXJCbGVuZGluZyIsInNldFN0YXRlIiwiX29uTW91c2VNb3ZlIiwiYnJ1c2giLCJpbnRlcmFjdGlvbkNvbmZpZyIsImV2dCIsIm5hdGl2ZUV2ZW50IiwiZW5hYmxlZCIsIm1vdXNlUG9zaXRpb24iLCJvZmZzZXRYIiwib2Zmc2V0WSIsIl9oYW5kbGVNYXBUb2dnbGVMYXllciIsImluZGV4IiwibWFwSW5kZXgiLCJ0b2dnbGVMYXllckZvck1hcCIsImxheWVySWQiLCJibGVuZGluZyIsIkxBWUVSX0JMRU5ESU5HUyIsImxheWVyQmxlbmRpbmciLCJibGVuZEZ1bmMiLCJibGVuZEVxdWF0aW9uIiwiYmxlbmRGdW5jU2VwYXJhdGUiLCJibGVuZEVxdWF0aW9uU2VwYXJhdGUiLCJCTEVORCIsIm1hcCIsIl9yZW5kZXJMYXllciIsIm92ZXJsYXlzIiwibGF5ZXJEYXRhIiwiaG92ZXJJbmZvIiwiY2xpY2tlZCIsIm1hcExheWVycyIsInN0YXRlIiwibGF5ZXIiLCJkYXRhIiwibGF5ZXJJbnRlcmFjdGlvbiIsIm9uSG92ZXIiLCJvbkxheWVySG92ZXIiLCJvbkNsaWNrIiwib2JqZWN0SG92ZXJlZCIsImxheWVyQ2FsbGJhY2tzIiwib25TZXRMYXllckRvbWFpbiIsInZhbCIsIl9zaG91bGRSZW5kZXJMYXllciIsImxheWVyT3ZlcmxheSIsInJlbmRlckxheWVyIiwibGVuZ3RoIiwiY29uY2F0IiwicmVSZW5kZXJLZXkiLCJwcmV2aW91c0xheWVycyIsIm5leHRQcm9wcyIsInByZXZQcm9wcyIsInByZXZTdGF0ZSIsIl9tYXAiLCJyZWZzIiwibWFwYm94IiwiZ2V0TWFwIiwib24iLCJfcmVuZGVyTWFwYm94TGF5ZXJzIiwiZm9yY2UiLCJvbk1hcFN0eWxlTG9hZGVkIiwib25NYXBSZW5kZXIiLCJvZmYiLCJkYXRhc2V0cyIsIm9iamVjdEluZm8iLCJ0b29sdGlwIiwicGlja2VkIiwibG5nTGF0Iiwib2JqZWN0Iiwib3ZlcmxheSIsImNvbmZpZyIsImlzVmlzaWJsZSIsImdldEhvdmVyRGF0YSIsImlkIiwiZGF0YUlkIiwiYWxsRGF0YSIsImZpZWxkcyIsInZpZXdwb3J0IiwiY29udGV4dCIsIl9nZXRIb3ZlclhZIiwieCIsInkiLCJwb3BvdmVyUHJvcHMiLCJmaWVsZHNUb1Nob3ciLCJmcmVlemVkIiwiQm9vbGVhbiIsIm9uQ2xvc2UiLCJzY3JlZW5Db29yZCIsInByb2plY3QiLCJpc0F2YWlsYWJsZUFuZFZpc2libGUiLCJzaG91bGRSZW5kZXJMYXllciIsImxheWVyT3JkZXIiLCJkZWNrR2xMYXllcnMiLCJzbGljZSIsInJldmVyc2UiLCJyZWR1Y2UiLCJpc1N0eWxlTG9hZGVkIiwibWFwYm94TGF5ZXJzIiwiZmluYWwiLCJtYXBTdHlsZSIsIm1hcFN0YXRlQWN0aW9ucyIsInVwZGF0ZU1hcCIsIm9uTWFwQ2xpY2siLCJib3R0b21NYXBTdHlsZSIsIm1hcGJveEFwaUFjY2Vzc1Rva2VuIiwibWFwQ29udHJvbHMiLCJ0b2dnbGVNYXBDb250cm9sIiwibWFwUHJvcHMiLCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXIiLCJvblZpZXdwb3J0Q2hhbmdlIiwidHJhbnNmb3JtUmVxdWVzdCIsImlzU3BsaXQiLCJpc0V4cG9ydCIsInNjYWxlIiwidG9nZ2xlUGVyc3BlY3RpdmUiLCJ0b2dnbGVTcGxpdE1hcCIsInRvZ2dsZUZ1bGxTY3JlZW4iLCJfcmVuZGVyT3ZlcmxheSIsIl9yZW5kZXJNYXBib3hPdmVybGF5cyIsInRvcE1hcFN0eWxlIiwiX3JlbmRlck9iamVjdExheWVyUG9wb3ZlciIsIkNvbXBvbmVudCIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsImlzUmVxdWlyZWQiLCJzdHJpbmciLCJhcnJheU9mIiwiYW55IiwiZnVuYyIsImJvb2wiLCJvbk1hcFRvZ2dsZUxheWVyIiwiZGVmYXVsdFByb3BzIiwiTWFwQ29tcG9uZW50IiwiTWFwYm94R0xNYXAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JBd0R3QkEsbUI7O0FBbkN4Qjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUdBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFHQTs7QUFFQTs7QUFHQTs7OztBQVhBO0FBYUEsSUFBTUMsWUFBWTtBQUNoQkMsYUFBVztBQUNUQyxhQUFTLGNBREE7QUFFVEMsY0FBVTtBQUZELEdBREs7QUFLaEJDLE9BQUs7QUFDSEQsY0FBVSxVQURQLEVBQ21CQyxLQUFLLEtBRHhCLEVBQytCQyxlQUFlO0FBRDlDO0FBTFcsQ0FBbEI7O0FBSEE7OztBQUxBO0FBaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUE4QkEsSUFBTUMsYUFBYSxTQUFiQSxVQUFhO0FB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QkFBVUUsTUFBVixDQUFpQkQsVUFKZjtBQUtqQmpDLGdCQUFZZ0Msb0JBQVVHLE9BQVYsQ0FBa0JILG9CQUFVSSxHQUE1QixFQUFpQ0gsVUFMNUI7QUFNakJoRyxlQUFXK0Ysb0JBQVVHLE9BQVYsQ0FBa0JILG9CQUFVSSxHQUE1QixFQUFpQ0gsVUFOM0I7QUFPakJ0SSxZQUFRcUksb0JBQVVHLE9BQVYsQ0FBa0JILG9CQUFVSSxHQUE1QixFQUFpQ0gsVUFQeEI7QUFRakJwSSxjQUFVbUksb0JBQVV2RCxNQUFWLENBQWlCd0QsVUFSVjtBQVNqQnpCLGNBQVV3QixvQkFBVXZELE1BQVYsQ0FBaUJ3RCxVQVRWO0FBVWpCbkIsaUJBQWFrQixvQkFBVXZELE1BQVYsQ0FBaUJ3RCxVQVZiO0FBV2pCcEIsMEJBQXNCbUIsb0JBQVVFLE1BQVYsQ0FBaUJELFVBWHRCO0FBWWpCbEIsc0JBQWtCaUIsb0JBQVVLLElBQVYsQ0FBZUosVUFaaEI7QUFhakI1SSxxQkFBaUIySSxvQkFBVXZELE1BQVYsQ0FBaUJ3RCxVQWJqQjtBQWNqQnhCLHFCQUFpQnVCLG9CQUFVdkQsTUFBVixDQUFpQndELFVBZGpCOztBQWdCakI7QUFDQVosY0FBVVcsb0JBQVVNLElBakJIO0FBa0JqQm5HLGFBQVM2RixvQkFBVXZELE1BbEJGO0FBbUJqQnZDLGVBQVc4RixvQkFBVXZELE1BbkJKO0FBb0JqQnJDLGVBQVc0RixvQkFBVXZELE1BcEJKO0FBcUJqQjhELHNCQUFrQlAsb0JBQVVLLElBckJYO0FBc0JqQnBFLHNCQUFrQitELG9CQUFVSyxJQXRCWDtBQXVCakJuRSxpQkFBYThELG9CQUFVSztBQXZCTixHQUY2QyxTQTRCekRHLFlBNUJ5RCxHQTRCMUM7QUFDcEJDLGtCQUFjQztBQURNLEdBNUIwQzs7O0FBcWFsRSxTQUFPeEosWUFBUDtBQUNEIiwiZmlsZSI6Im1hcC1jb250YWluZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTggVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBsaWJyYXJpZXNcbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBNYXBib3hHTE1hcCBmcm9tICdyZWFjdC1tYXAtZ2wnO1xuaW1wb3J0IERlY2tHTCBmcm9tICdkZWNrLmdsJztcbmltcG9ydCB7R0x9IGZyb20gJ2x1bWEuZ2wnO1xuXG4vLyBjb21wb25lbnRzXG5pbXBvcnQgTWFwUG9wb3ZlckZhY3RvcnkgZnJvbSAnY29tcG9uZW50cy9tYXAvbWFwLXBvcG92ZXInO1xuaW1wb3J0IE1hcENvbnRyb2xGYWN0b3J5IGZyb20gJ2NvbXBvbmVudHMvbWFwL21hcC1jb250cm9sJztcbmltcG9ydCB7U3R5bGVkTWFwQ29udGFpbmVyfSBmcm9tICdjb21wb25lbnRzL2NvbW1vbi9zdHlsZWQtY29tcG9uZW50cyc7XG5cbi8vIE92ZXJsYXkgdHlwZVxuaW1wb3J0IHtnZW5lcmF0ZU1hcGJveExheWVycywgdXBkYXRlTWFwYm94TGF5ZXJzfSBmcm9tICcuLi9sYXllcnMvbWFwYm94LXV0aWxzJztcblxuaW1wb3J0IHt0cmFuc2Zvcm1SZXF1ZXN0fSBmcm9tICd1dGlscy9tYXAtc3R5bGUtdXRpbHMvbWFwYm94LXV0aWxzJztcblxuLy8gZGVmYXVsdC1zZXR0aW5nc1xuaW1wb3J0IHtMQVlFUl9CTEVORElOR1N9IGZyb20gJ2NvbnN0YW50cy9kZWZhdWx0LXNldHRpbmdzJztcblxuY29uc3QgTUFQX1NUWUxFID0ge1xuICBjb250YWluZXI6IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICB9LFxuICB0b3A6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJywgdG9wOiAnMHB4JywgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gIH1cbn07XG5cbmNvbnN0IGdldEdsQ29uc3QgPSBkID0+IEdMW2RdO1xuXG5jb25zdCBNQVBCT1hHTF9TVFlMRV9VUERBVEUgPSAnc3R5bGUubG9hZCc7XG5NYXBDb250YWluZXJGYWN0b3J5LmRlcHMgPSBbXG4gIE1hcFBvcG92ZXJGYWN0b3J5LCBNYXBDb250cm9sRmFjdG9yeV07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1hcENvbnRhaW5lckZhY3RvcnkoTWFwUG9wb3ZlciwgTWFwQ29udHJvbCkge1xuICBjbGFzcyBNYXBDb250YWluZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAvLyByZXF1aXJlZFxuICAgICAgZGF0YXNldHM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICBpbnRlcmFjdGlvbkNvbmZpZzogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgICAgbGF5ZXJCbGVuZGluZzogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgICAgbGF5ZXJPcmRlcjogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmFueSkuaXNSZXF1aXJlZCxcbiAgICAgIGxheWVyRGF0YTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmFueSkuaXNSZXF1aXJlZCxcbiAgICAgIGxheWVyczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmFueSkuaXNSZXF1aXJlZCxcbiAgICAgIG1hcFN0YXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgICBtYXBTdHlsZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgICAgbWFwQ29udHJvbHM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgICB0b2dnbGVNYXBDb250cm9sOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgdmlzU3RhdGVBY3Rpb25zOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgICBtYXBTdGF0ZUFjdGlvbnM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblxuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIGlzRXhwb3J0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgIGNsaWNrZWQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICBob3ZlckluZm86IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICBtYXBMYXllcnM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICBvbk1hcFRvZ2dsZUxheWVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgIG9uTWFwU3R5bGVMb2FkZWQ6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgb25NYXBSZW5kZXI6IFByb3BUeXBlcy5mdW5jXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICBNYXBDb21wb25lbnQ6IE1hcGJveEdMTWFwXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICByZVJlbmRlcktleTogMCxcbiAgICAgICAgZ2w6IG51bGwsXG4gICAgICAgIG1vdXNlUG9zaXRpb246IFswLCAwXVxuICAgICAgfTtcbiAgICAgIHRoaXMucHJldmlvdXNMYXllcnMgPSB7XG4gICAgICAgIC8vIFtsYXllcnMuaWRdOiBtYXBib3hMYXllckNvbmZpZ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnByb3BzLm1hcFN0YXRlLmRyYWdSb3RhdGUgIT09IG5leHRQcm9wcy5tYXBTdGF0ZS5kcmFnUm90YXRlIHx8XG4gICAgICAgIHRoaXMucHJvcHMubGF5ZXJCbGVuZGluZyAhPT0gbmV4dFByb3BzLmxheWVyQmxlbmRpbmdcbiAgICAgICkge1xuICAgICAgICAvLyBpbmNyZW1lbnQgcmVyZW5kZXIga2V5IHRvIGZvcmNlIGdsIHJlaW5pdGlhbGl6ZSB3aGVuXG4gICAgICAgIC8vIHBlcnNwZWN0aXZlIG9yIGxheWVyIGJsZW5kaW5nIGNoYW5nZWRcbiAgICAgICAgLy8gVE9ETzogbGF5ZXIgYmxlbmRpbmcgY2FuIG5vdyBiZSBpbXBsZW1lbnRlZCBwZXIgbGF5ZXIgYmFzZVxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICByZVJlbmRlcktleTogdGhpcy5zdGF0ZS5yZVJlbmRlcktleSArIDFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICBpZiAoIXRoaXMuX21hcCAmJiB0aGlzLnJlZnMubWFwYm94KSB7XG4gICAgICAgIHRoaXMuX21hcCA9IHRoaXMucmVmcy5tYXBib3guZ2V0TWFwKCk7XG4gICAgICAgIC8vIGJpbmQgbWFwYm94Z2wgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgdGhpcy5fbWFwLm9uKE1BUEJPWEdMX1NUWUxFX1VQREFURSwgKCkgPT4ge1xuICAgICAgICAgIC8vIGZvcmNlIHJlZnJlc2ggbWFwYm94Z2wgbGF5ZXJzXG5cbiAgICAgICAgICB1cGRhdGVNYXBib3hMYXllcnMoXG4gICAgICAgICAgICB0aGlzLl9tYXAsXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJNYXBib3hMYXllcnMoKSxcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNMYXllcnMsXG4gICAgICAgICAgICB0aGlzLnByb3BzLm1hcExheWVycyxcbiAgICAgICAgICAgIHtmb3JjZTogdHJ1ZX1cbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uTWFwU3R5bGVMb2FkZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25NYXBTdHlsZUxvYWRlZCh0aGlzLl9tYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fbWFwLm9uKCdyZW5kZXInLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uTWFwUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uTWFwUmVuZGVyKHRoaXMuX21hcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIC8vIHVuYmluZCBtYXBib3hnbCBldmVudCBsaXN0ZW5lclxuICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICB0aGlzLl9tYXAub2ZmKE1BUEJPWEdMX1NUWUxFX1VQREFURSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogY29tcG9uZW50IHByaXZhdGUgZnVuY3Rpb25zICovXG5cbiAgICBfb25DbG9zZU1hcFBvcG92ZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLnByb3BzLnZpc1N0YXRlQWN0aW9ucy5vbkxheWVyQ2xpY2sobnVsbCk7XG4gICAgfTtcblxuICAgIF9vbkxheWVyU2V0RG9tYWluID0gKGlkeCwgY29sb3JEb21haW4pID0+IHtcbiAgICAgIHRoaXMucHJvcHMudmlzU3RhdGVBY3Rpb25zLmxheWVyQ29uZmlnQ2hhbmdlKHRoaXMucHJvcHMubGF5ZXJzW2lkeF0sIHtcbiAgICAgICAgY29sb3JEb21haW5cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfb25XZWJHTEluaXRpYWxpemVkID0gZ2wgPT4ge1xuICAgICAgLy8gZW5hYmxlIGRlcHRoIHRlc3QgZm9yIHBlcnNwZWN0aXZlIG1vZGVcbiAgICAgIGlmICh0aGlzLnByb3BzLm1hcFN0YXRlLmRyYWdSb3RhdGUpIHtcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICBnbC5kZXB0aEZ1bmMoZ2wuTEVRVUFMKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFsbG93IFVpbnQzMiBpbmRpY2VzIGluIGJ1aWxkaW5nIGxheWVyXG4gICAgICBnbC5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKTtcblxuICAgICAgdGhpcy5fdG9nZ2xlbGF5ZXJCbGVuZGluZyhnbCk7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe2dsfSk7XG4gICAgfTtcblxuICAgIF9vbk1vdXNlTW92ZSA9IGV2dCA9PiB7XG4gICAgICBjb25zdCB7aW50ZXJhY3Rpb25Db25maWc6IHticnVzaH19ID0gdGhpcy5wcm9wcztcblxuICAgICAgaWYgKGV2dC5uYXRpdmVFdmVudCAmJiBicnVzaC5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIG1vdXNlUG9zaXRpb246IFtldnQubmF0aXZlRXZlbnQub2Zmc2V0WCwgZXZ0Lm5hdGl2ZUV2ZW50Lm9mZnNldFldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfaGFuZGxlTWFwVG9nZ2xlTGF5ZXIgPSBsYXllcklkID0+IHtcbiAgICAgIGNvbnN0IHtpbmRleDogbWFwSW5kZXggPSAwLCB2aXNTdGF0ZUFjdGlvbnN9ID0gdGhpcy5wcm9wcztcbiAgICAgIHZpc1N0YXRlQWN0aW9ucy50b2dnbGVMYXllckZvck1hcChtYXBJbmRleCwgbGF5ZXJJZCk7XG4gICAgfTtcblxuICAgIC8qIGRlY2suZ2wgZG9lc24ndCBzdXBwb3J0IGJsZW5kRnVuY1NlcGFyYXRlIHlldFxuICAgICAqIHNvIHdlJ3JlIGFwcGx5aW5nIHRoZSBibGVuZGluZyBvdXJzZWx2ZXNcbiAgICAqL1xuICAgIF90b2dnbGVsYXllckJsZW5kaW5nID0gZ2wgPT4ge1xuICAgICAgY29uc3QgYmxlbmRpbmcgPSBMQVlFUl9CTEVORElOR1NbdGhpcy5wcm9wcy5sYXllckJsZW5kaW5nXTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5hYmxlLFxuICAgICAgICBibGVuZEZ1bmMsXG4gICAgICAgIGJsZW5kRXF1YXRpb24sXG4gICAgICAgIGJsZW5kRnVuY1NlcGFyYXRlLFxuICAgICAgICBibGVuZEVxdWF0aW9uU2VwYXJhdGVcbiAgICAgIH0gPSBibGVuZGluZztcblxuICAgICAgaWYgKGVuYWJsZSkge1xuICAgICAgICBnbC5lbmFibGUoR0wuQkxFTkQpO1xuICAgICAgICBpZiAoYmxlbmRGdW5jKSB7XG4gICAgICAgICAgZ2wuYmxlbmRGdW5jKC4uLmJsZW5kRnVuYy5tYXAoZ2V0R2xDb25zdCkpO1xuICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb24oR0xbYmxlbmRFcXVhdGlvbl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKC4uLmJsZW5kRnVuY1NlcGFyYXRlLm1hcChnZXRHbENvbnN0KSk7XG4gICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKC4uLmJsZW5kRXF1YXRpb25TZXBhcmF0ZS5tYXAoZ2V0R2xDb25zdCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC5kaXNhYmxlKEdMLkJMRU5EKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbnMgKi9cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgICBfcmVuZGVyT2JqZWN0TGF5ZXJQb3BvdmVyKCkge1xuICAgICAgLy8gVE9ETzogbW92ZSB0aGlzIGludG8gcmVkdWNlciBzbyBpdCBjYW4gYmUgdGVzdGVkXG4gICAgICBjb25zdCB7XG4gICAgICAgIG1hcFN0YXRlLFxuICAgICAgICBob3ZlckluZm8sXG4gICAgICAgIGNsaWNrZWQsXG4gICAgICAgIGRhdGFzZXRzLFxuICAgICAgICBpbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAgICAgbGF5ZXJzLFxuICAgICAgICBtYXBMYXllcnNcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAvLyBpZiBjbGlja2VkIHNvbWV0aGluZywgaWdub3JlIGhvdmVyIGJlaGF2aW9yXG4gICAgICBjb25zdCBvYmplY3RJbmZvID0gY2xpY2tlZCB8fCBob3ZlckluZm87XG4gICAgICBpZiAoXG4gICAgICAgICFpbnRlcmFjdGlvbkNvbmZpZy50b29sdGlwLmVuYWJsZWQgfHxcbiAgICAgICAgIW9iamVjdEluZm8gfHxcbiAgICAgICAgIW9iamVjdEluZm8ucGlja2VkXG4gICAgICApIHtcbiAgICAgICAgLy8gbm90aGluZyBob3ZlcmVkXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7bG5nTGF0LCBvYmplY3QsIGxheWVyOiBvdmVybGF5fSA9IG9iamVjdEluZm87XG5cbiAgICAgIC8vIGRlY2tnbCBsYXllciB0byBrZXBsZXItZ2wgbGF5ZXJcbiAgICAgIGNvbnN0IGxheWVyID0gbGF5ZXJzW292ZXJsYXkucHJvcHMuaWR4XTtcblxuICAgICAgaWYgKFxuICAgICAgICAhbGF5ZXIgfHxcbiAgICAgICAgIWxheWVyLmNvbmZpZy5pc1Zpc2libGUgfHxcbiAgICAgICAgIW9iamVjdCB8fFxuICAgICAgICAhbGF5ZXIuZ2V0SG92ZXJEYXRhIHx8XG4gICAgICAgIChtYXBMYXllcnMgJiYgIW1hcExheWVyc1tsYXllci5pZF0uaXNWaXNpYmxlKVxuICAgICAgKSB7XG4gICAgICAgIC8vIGxheWVyIGlzIG5vdCB2aXNpYmxlXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7Y29uZmlnOiB7ZGF0YUlkfX0gPSBsYXllcjtcbiAgICAgIGNvbnN0IHthbGxEYXRhLCBmaWVsZHN9ID0gZGF0YXNldHNbZGF0YUlkXTtcbiAgICAgIGNvbnN0IGRhdGEgPSBsYXllci5nZXRIb3ZlckRhdGEob2JqZWN0LCBhbGxEYXRhKTtcblxuICAgICAgLy8gcHJvamVjdCBsbmdsYXQgdG8gc2NyZWVuIHNvIHRoYXQgdG9vbHRpcCBmb2xsb3dzIHRoZSBvYmplY3Qgb24gem9vbVxuICAgICAgY29uc3Qge3ZpZXdwb3J0fSA9IG92ZXJsYXkuY29udGV4dDtcbiAgICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuX2dldEhvdmVyWFkodmlld3BvcnQsIGxuZ0xhdCkgfHwgb2JqZWN0SW5mbztcblxuICAgICAgY29uc3QgcG9wb3ZlclByb3BzID0ge1xuICAgICAgICBkYXRhLFxuICAgICAgICBmaWVsZHMsXG4gICAgICAgIGZpZWxkc1RvU2hvdzogaW50ZXJhY3Rpb25Db25maWcudG9vbHRpcC5jb25maWcuZmllbGRzVG9TaG93W2RhdGFJZF0sXG4gICAgICAgIGxheWVyLFxuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGZyZWV6ZWQ6IEJvb2xlYW4oY2xpY2tlZCksXG4gICAgICAgIG9uQ2xvc2U6IHRoaXMuX29uQ2xvc2VNYXBQb3BvdmVyLFxuICAgICAgICBtYXBTdGF0ZVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8TWFwUG9wb3ZlciB7Li4ucG9wb3ZlclByb3BzfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbiAgICBfZ2V0SG92ZXJYWSh2aWV3cG9ydCwgbG5nTGF0KSB7XG4gICAgICBjb25zdCBzY3JlZW5Db29yZCA9ICF2aWV3cG9ydCB8fCAhbG5nTGF0ID8gbnVsbCA6IHZpZXdwb3J0LnByb2plY3QobG5nTGF0KTtcblxuICAgICAgcmV0dXJuIHNjcmVlbkNvb3JkICYmIHt4OiBzY3JlZW5Db29yZFswXSwgeTogc2NyZWVuQ29vcmRbMV19O1xuICAgIH1cblxuICAgIF9zaG91bGRSZW5kZXJMYXllcihsYXllciwgZGF0YSwgbWFwTGF5ZXJzKSB7XG4gICAgICBjb25zdCBpc0F2YWlsYWJsZUFuZFZpc2libGUgPVxuICAgICAgICAhKG1hcExheWVycyAmJiBtYXBMYXllcnNbbGF5ZXIuaWRdKSB8fCBtYXBMYXllcnNbbGF5ZXIuaWRdLmlzVmlzaWJsZTtcbiAgICAgIHJldHVybiBsYXllci5zaG91bGRSZW5kZXJMYXllcihkYXRhKSAmJiBpc0F2YWlsYWJsZUFuZFZpc2libGU7XG4gICAgfVxuXG4gICAgX3JlbmRlckxheWVyID0gKG92ZXJsYXlzLCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5ZXJzLFxuICAgICAgICBsYXllckRhdGEsXG4gICAgICAgIGhvdmVySW5mbyxcbiAgICAgICAgY2xpY2tlZCxcbiAgICAgICAgbWFwTGF5ZXJzLFxuICAgICAgICBtYXBTdGF0ZSxcbiAgICAgICAgdmlzU3RhdGVBY3Rpb25zLFxuICAgICAgICBpbnRlcmFjdGlvbkNvbmZpZ1xuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7bW91c2VQb3NpdGlvbn0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgbGF5ZXIgPSBsYXllcnNbaWR4XTtcbiAgICAgIGNvbnN0IGRhdGEgPSBsYXllckRhdGFbaWR4XTtcblxuICAgICAgY29uc3QgbGF5ZXJJbnRlcmFjdGlvbiA9IHtcbiAgICAgICAgb25Ib3ZlcjogdmlzU3RhdGVBY3Rpb25zLm9uTGF5ZXJIb3ZlcixcbiAgICAgICAgb25DbGljazogdmlzU3RhdGVBY3Rpb25zLm9uTGF5ZXJDbGljayxcbiAgICAgICAgbW91c2VQb3NpdGlvblxuICAgICAgfTtcblxuICAgICAgY29uc3Qgb2JqZWN0SG92ZXJlZCA9IGNsaWNrZWQgfHwgaG92ZXJJbmZvO1xuICAgICAgY29uc3QgbGF5ZXJDYWxsYmFja3MgPSB7XG4gICAgICAgIG9uU2V0TGF5ZXJEb21haW46IHZhbCA9PiB0aGlzLl9vbkxheWVyU2V0RG9tYWluKGlkeCwgdmFsKVxuICAgICAgfTtcblxuICAgICAgaWYgKCF0aGlzLl9zaG91bGRSZW5kZXJMYXllcihsYXllciwgZGF0YSwgbWFwTGF5ZXJzKSkge1xuICAgICAgICByZXR1cm4gb3ZlcmxheXM7XG4gICAgICB9XG5cbiAgICAgIGxldCBsYXllck92ZXJsYXkgPSBbXTtcblxuICAgICAgLy8gTGF5ZXIgaXMgTGF5ZXIgY2xhc3NcbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIucmVuZGVyTGF5ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbGF5ZXJPdmVybGF5ID0gbGF5ZXIucmVuZGVyTGF5ZXIoe1xuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIGxheWVySW50ZXJhY3Rpb24sXG4gICAgICAgICAgb2JqZWN0SG92ZXJlZCxcbiAgICAgICAgICBtYXBTdGF0ZSxcbiAgICAgICAgICBpbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAgICAgICBsYXllckNhbGxiYWNrc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxheWVyT3ZlcmxheS5sZW5ndGgpIHtcbiAgICAgICAgb3ZlcmxheXMgPSBvdmVybGF5cy5jb25jYXQobGF5ZXJPdmVybGF5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdmVybGF5cztcbiAgICB9O1xuXG4gICAgX3JlbmRlck92ZXJsYXkoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1hcFN0YXRlLFxuICAgICAgICBsYXllckRhdGEsXG4gICAgICAgIGxheWVyT3JkZXJcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICBsZXQgZGVja0dsTGF5ZXJzID0gW107XG5cbiAgICAgIC8vIHdhaXQgdW50aWwgZGF0YSBpcyByZWFkeSBiZWZvcmUgcmVuZGVyIGRhdGEgbGF5ZXJzXG4gICAgICBpZiAobGF5ZXJEYXRhICYmIGxheWVyRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gbGFzdCBsYXllciByZW5kZXIgZmlyc3RcbiAgICAgICAgZGVja0dsTGF5ZXJzID0gbGF5ZXJPcmRlclxuICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgIC5yZWR1Y2UodGhpcy5fcmVuZGVyTGF5ZXIsIFtdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPERlY2tHTFxuICAgICAgICAgIHsuLi5tYXBTdGF0ZX1cbiAgICAgICAgICBpZD1cImRlZmF1bHQtZGVja2dsLW92ZXJsYXlcIlxuICAgICAgICAgIGxheWVycz17ZGVja0dsTGF5ZXJzfVxuICAgICAgICAgIGtleT17dGhpcy5zdGF0ZS5yZVJlbmRlcktleX1cbiAgICAgICAgICBvbldlYkdMSW5pdGlhbGl6ZWQ9e3RoaXMuX29uV2ViR0xJbml0aWFsaXplZH1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgX3JlbmRlck1hcGJveExheWVycygpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5ZXJzLFxuICAgICAgICBsYXllckRhdGEsXG4gICAgICAgIGxheWVyT3JkZXJcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICByZXR1cm4gZ2VuZXJhdGVNYXBib3hMYXllcnMobGF5ZXJzLCBsYXllckRhdGEsIGxheWVyT3JkZXIpO1xuICAgIH1cblxuICAgIF9yZW5kZXJNYXBib3hPdmVybGF5cygpIHtcbiAgICAgIGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmlzU3R5bGVMb2FkZWQoKSkge1xuXG4gICAgICAgIGNvbnN0IG1hcGJveExheWVycyA9IHRoaXMuX3JlbmRlck1hcGJveExheWVycygpO1xuXG4gICAgICAgIHVwZGF0ZU1hcGJveExheWVycyhcbiAgICAgICAgICB0aGlzLl9tYXAsXG4gICAgICAgICAgbWFwYm94TGF5ZXJzLFxuICAgICAgICAgIHRoaXMucHJldmlvdXNMYXllcnMsXG4gICAgICAgICAgdGhpcy5wcm9wcy5tYXBMYXllcnNcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnByZXZpb3VzTGF5ZXJzID0gbWFwYm94TGF5ZXJzLnJlZHVjZSgoZmluYWwsIGxheWVyKSA9PiAoe1xuICAgICAgICAgIC4uLmZpbmFsLFxuICAgICAgICAgIFtsYXllci5pZF06IGxheWVyLmNvbmZpZ1xuICAgICAgICB9KSwge30pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgY29uc3Qge21hcFN0YXRlLCBtYXBTdHlsZSwgbWFwU3RhdGVBY3Rpb25zfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7dXBkYXRlTWFwLCBvbk1hcENsaWNrfSA9IG1hcFN0YXRlQWN0aW9ucztcblxuICAgICAgaWYgKCFtYXBTdHlsZS5ib3R0b21NYXBTdHlsZSkge1xuICAgICAgICAvLyBzdHlsZSBub3QgeWV0IGxvYWRlZFxuICAgICAgICByZXR1cm4gPGRpdi8+O1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7bWFwTGF5ZXJzLCBsYXllcnMsIGRhdGFzZXRzLCBtYXBib3hBcGlBY2Nlc3NUb2tlbixcbiAgICAgICAgbWFwQ29udHJvbHMsIHRvZ2dsZU1hcENvbnRyb2x9ID0gdGhpcy5wcm9wcztcblxuICAgICAgY29uc3QgbWFwUHJvcHMgPSB7XG4gICAgICAgIC4uLm1hcFN0YXRlLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWUsXG4gICAgICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgICAgICBvblZpZXdwb3J0Q2hhbmdlOiB1cGRhdGVNYXAsXG4gICAgICAgIHRyYW5zZm9ybVJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxTdHlsZWRNYXBDb250YWluZXIgc3R5bGU9e01BUF9TVFlMRS5jb250YWluZXJ9IG9uTW91c2VNb3ZlPXt0aGlzLl9vbk1vdXNlTW92ZX0+XG4gICAgICAgICAgPE1hcENvbnRyb2xcbiAgICAgICAgICAgIGRhdGFzZXRzPXtkYXRhc2V0c31cbiAgICAgICAgICAgIGRyYWdSb3RhdGU9e21hcFN0YXRlLmRyYWdSb3RhdGV9XG4gICAgICAgICAgICBpc1NwbGl0PXttYXBTdGF0ZS5pc1NwbGl0fVxuICAgICAgICAgICAgaXNFeHBvcnQ9e3RoaXMucHJvcHMuaXNFeHBvcnR9XG4gICAgICAgICAgICBsYXllcnM9e2xheWVyc31cbiAgICAgICAgICAgIG1hcEluZGV4PXt0aGlzLnByb3BzLmluZGV4fVxuICAgICAgICAgICAgbWFwTGF5ZXJzPXttYXBMYXllcnN9XG4gICAgICAgICAgICBtYXBDb250cm9scz17bWFwQ29udHJvbHN9XG4gICAgICAgICAgICBzY2FsZT17bWFwU3RhdGUuc2NhbGUgfHwgMX1cbiAgICAgICAgICAgIHRvcD17MH1cbiAgICAgICAgICAgIG9uVG9nZ2xlUGVyc3BlY3RpdmU9e21hcFN0YXRlQWN0aW9ucy50b2dnbGVQZXJzcGVjdGl2ZX1cbiAgICAgICAgICAgIG9uVG9nZ2xlU3BsaXRNYXA9e21hcFN0YXRlQWN0aW9ucy50b2dnbGVTcGxpdE1hcH1cbiAgICAgICAgICAgIG9uTWFwVG9nZ2xlTGF5ZXI9e3RoaXMuX2hhbmRsZU1hcFRvZ2dsZUxheWVyfVxuICAgICAgICAgICAgb25Ub2dnbGVGdWxsU2NyZWVuPXttYXBTdGF0ZUFjdGlvbnMudG9nZ2xlRnVsbFNjcmVlbn1cbiAgICAgICAgICAgIG9uVG9nZ2xlTWFwQ29udHJvbD17dG9nZ2xlTWFwQ29udHJvbH1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDx0aGlzLnByb3BzLk1hcENvbXBvbmVudFxuICAgICAgICAgICAgey4uLm1hcFByb3BzfVxuICAgICAgICAgICAga2V5PVwiYm90dG9tXCJcbiAgICAgICAgICAgIHJlZj1cIm1hcGJveFwiXG4gICAgICAgICAgICBtYXBTdHlsZT17bWFwU3R5bGUuYm90dG9tTWFwU3R5bGV9XG4gICAgICAgICAgICBvbkNsaWNrPXtvbk1hcENsaWNrfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt0aGlzLl9yZW5kZXJPdmVybGF5KCl9XG4gICAgICAgICAgICB7dGhpcy5fcmVuZGVyTWFwYm94T3ZlcmxheXMoKX1cbiAgICAgICAgICA8L3RoaXMucHJvcHMuTWFwQ29tcG9uZW50PlxuICAgICAgICAgIHttYXBTdHlsZS50b3BNYXBTdHlsZSAmJiAoXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXtNQVBfU1RZTEUudG9wfT5cbiAgICAgICAgICAgICAgPHRoaXMucHJvcHMuTWFwQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgey4uLm1hcFByb3BzfVxuICAgICAgICAgICAgICAgIGtleT1cInRvcFwiXG4gICAgICAgICAgICAgICAgbWFwU3R5bGU9e21hcFN0eWxlLnRvcE1hcFN0eWxlfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKX1cbiAgICAgICAgICB7dGhpcy5fcmVuZGVyT2JqZWN0TGF5ZXJQb3BvdmVyKCl9XG4gICAgICAgIDwvU3R5bGVkTWFwQ29udGFpbmVyPlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTWFwQ29udGFpbmVyO1xufVxuIl19