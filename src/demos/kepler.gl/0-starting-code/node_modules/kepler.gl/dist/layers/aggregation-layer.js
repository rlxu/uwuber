'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.aggregateRequiredColumns = exports.getValueAggr = exports.pointPosResolver = exports.pointPosAccessor = undefined;

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _lodash = require('lodash.memoize');

var _lodash2 = _interopRequireDefault(_lodash);

var _baseLayer = require('./base-layer');

var _baseLayer2 = _interopRequireDefault(_baseLayer);

var _colorUtils = require('../utils/color-utils');

var _aggregateUtils = require('../utils/aggregate-utils');

var _defaultSettings = require('../constants/default-settings');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pointPosAccessor = exports.pointPosAccessor = function pointPosAccessor(_ref) {
  var lat = _ref.lat,
      lng = _ref.lng;
  return function (d) {
    return [d[lng.fieldIdx], d[lat.fieldIdx]];
  };
}; // Copyright (c) 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var pointPosResolver = exports.pointPosResolver = function pointPosResolver(_ref2) {
  var lat = _ref2.lat,
      lng = _ref2.lng;
  return lat.fieldIdx + '-' + lng.fieldIdx;
};

var getValueAggr = exports.getValueAggr = function getValueAggr(field, aggregation) {
  return function (points) {
    return (0, _aggregateUtils.aggregate)(points.map(function (p) {
      return p[field.tableFieldIndex - 1];
    }), aggregation);
  };
};

var aggrResolver = function aggrResolver(field, aggregation) {
  return field.name + '-' + aggregation;
};

var getLayerColorRange = function getLayerColorRange(colorRange) {
  return colorRange.colors.map(_colorUtils.hexToRgb);
};

var aggregateRequiredColumns = exports.aggregateRequiredColumns = ['lat', 'lng'];

var AggregationLayer = function (_Layer) {
  (0, _inherits3.default)(AggregationLayer, _Layer);

  function AggregationLayer(props) {
    (0, _classCallCheck3.default)(this, AggregationLayer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (AggregationLayer.__proto__ || Object.getPrototypeOf(AggregationLayer)).call(this, props));

    _this.getPosition = (0, _lodash2.default)(pointPosAccessor, pointPosResolver);
    _this.getColorValue = (0, _lodash2.default)(getValueAggr, aggrResolver);
    _this.getColorRange = (0, _lodash2.default)(getLayerColorRange);
    _this.getElevationValue = (0, _lodash2.default)(getValueAggr, aggrResolver);
    return _this;
  }

  (0, _createClass3.default)(AggregationLayer, [{
    key: 'getHoverData',
    value: function getHoverData(object) {
      // return aggregated object
      return object;
    }

    /**
     * Aggregation layer handles visual channel aggregation inside deck.gl layer
     */

  }, {
    key: 'updateLayerVisualChannel',
    value: function updateLayerVisualChannel(_ref3, channel) {
      var data = _ref3.data,
          allData = _ref3.allData;

      this.validateVisualChannel(channel);
    }

    /**
     * Aggregation layer handles visual channel aggregation inside deck.gl layer
     */

  }, {
    key: 'updateLayerDomain',
    value: function updateLayerDomain(dataset, newFilter) {
      return this;
    }
  }, {
    key: 'updateLayerMeta',
    value: function updateLayerMeta(allData, getPosition) {
      // get bounds from points
      var bounds = this.getPointsBounds(allData, getPosition);

      // get lightSettings from points
      var lightSettings = this.getLightSettingsFromBounds(bounds);

      this.updateMeta({ bounds: bounds, lightSettings: lightSettings });
    }
  }, {
    key: 'formatLayerData',
    value: function formatLayerData(_, allData, filteredIndex, oldLayerData) {
      var opt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

      var getPosition = this.getPosition(this.config.columns);

      if (!oldLayerData || oldLayerData.getPosition !== getPosition) {
        this.updateLayerMeta(allData, getPosition);
      }

      var getColorValue = this.config.colorField ? this.getColorValue(this.config.colorField, this.config.visConfig.colorAggregation) : undefined;

      var getElevationValue = this.config.sizeField ? this.getElevationValue(this.config.sizeField, this.config.visConfig.sizeAggregation) : undefined;

      var data = void 0;
      if (oldLayerData && oldLayerData.data && opt.sameData && oldLayerData.getPosition === getPosition) {
        data = oldLayerData.data;
      } else {
        data = filteredIndex.map(function (i) {
          return allData[i];
        });
      }

      return (0, _extends3.default)({
        data: data,
        getPosition: getPosition
      }, getColorValue ? { getColorValue: getColorValue } : {}, getElevationValue ? { getElevationValue: getElevationValue } : {});
    }
  }, {
    key: 'isAggregated',
    get: function get() {
      return true;
    }
  }, {
    key: 'requiredLayerColumns',
    get: function get() {
      return aggregateRequiredColumns;
    }
  }, {
    key: 'columnPairs',
    get: function get() {
      return this.defaultPointColumnPairs;
    }
  }, {
    key: 'noneLayerDataAffectingProps',
    get: function get() {
      return [].concat((0, _toConsumableArray3.default)((0, _get3.default)(AggregationLayer.prototype.__proto__ || Object.getPrototypeOf(AggregationLayer.prototype), 'noneLayerDataAffectingProps', this)), ['enable3d', 'colorRange', 'colorScale', 'colorDomain', 'sizeRange', 'sizeScale', 'sizeDomain', 'percentile', 'coverage', 'elevationPercentile', 'elevationScale']);
    }
  }, {
    key: 'visualChannels',
    get: function get() {
      return {
        color: {
          property: 'color',
          field: 'colorField',
          scale: 'colorScale',
          domain: 'colorDomain',
          range: 'colorRange',
          key: 'color',
          channelScaleType: _defaultSettings.CHANNEL_SCALES.colorAggr,
          defaultMeasure: 'Point Count'
        },
        size: {
          property: 'height',
          field: 'sizeField',
          scale: 'sizeScale',
          domain: 'sizeDomain',
          range: 'sizeRange',
          key: 'size',
          channelScaleType: _defaultSettings.CHANNEL_SCALES.sizeAggr,
          defaultMeasure: 'Point Count',
          condition: function condition(config) {
            return config.visConfig.enable3d;
          }
        }
      };
    }
  }]);
  return AggregationLayer;
}(_baseLayer2.default);

exports.default = AggregationLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYXllcnMvYWdncmVnYXRpb24tbGF5ZXIuanMiXSwibmFtZXMiOlsicG9pbnRQb3NBY2Nlc3NvciIsImxhdCIsImxuZyIsImQiLCJmaWVsZElkeCIsInBvaW50UG9zUmVzb2x2ZXIiLCJnZXRWYWx1ZUFnZ3IiLCJmaWVsZCIsImFnZ3JlZ2F0aW9uIiwicG9pbnRzIiwibWFwIiwicCIsInRhYmxlRmllbGRJbmRleCIsImFnZ3JSZXNvbHZlciIsIm5hbWUiLCJnZXRMYXllckNvbG9yUmFuZ2UiLCJjb2xvclJhbmdlIiwiY29sb3JzIiwiaGV4VG9SZ2IiLCJhZ2dyZWdhdGVSZXF1aXJlZENvbHVtbnMiLCJBZ2dyZWdhdGlvbkxheWVyIiwicHJvcHMiLCJnZXRQb3NpdGlvbiIsImdldENvbG9yVmFsdWUiLCJnZXRDb2xvclJhbmdlIiwiZ2V0RWxldmF0aW9uVmFsdWUiLCJvYmplY3QiLCJjaGFubmVsIiwiZGF0YSIsImFsbERhdGEiLCJ2YWxpZGF0ZVZpc3VhbENoYW5uZWwiLCJkYXRhc2V0IiwibmV3RmlsdGVyIiwiYm91bmRzIiwiZ2V0UG9pbnRzQm91bmRzIiwibGlnaHRTZXR0aW5ncyIsImdldExpZ2h0U2V0dGluZ3NGcm9tQm91bmRzIiwidXBkYXRlTWV0YSIsIl8iLCJmaWx0ZXJlZEluZGV4Iiwib2xkTGF5ZXJEYXRhIiwib3B0IiwiY29uZmlnIiwiY29sdW1ucyIsInVwZGF0ZUxheWVyTWV0YSIsImNvbG9yRmllbGQiLCJ2aXNDb25maWciLCJjb2xvckFnZ3JlZ2F0aW9uIiwidW5kZWZpbmVkIiwic2l6ZUZpZWxkIiwic2l6ZUFnZ3JlZ2F0aW9uIiwic2FtZURhdGEiLCJpIiwiZGVmYXVsdFBvaW50Q29sdW1uUGFpcnMiLCJjb2xvciIsInByb3BlcnR5Iiwic2NhbGUiLCJkb21haW4iLCJyYW5nZSIsImtleSIsImNoYW5uZWxTY2FsZVR5cGUiLCJDSEFOTkVMX1NDQUxFUyIsImNvbG9yQWdnciIsImRlZmF1bHRNZWFzdXJlIiwic2l6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TUFFRSxVQUZGLEVBR0UsWUFIRixFQUlFLFlBSkYsRUFLRSxhQUxGLEVBTUUsV0FORixFQU9FLFdBUEYsRUFRRSxZQVJGLEVBU0UsWUFURixFQVVFLFVBVkYsRUFXRSxxQkFYRixFQVlFLGdCQVpGO0FBY0Q7Ozt3QkFFb0I7QUFDbkIsYUFBTztBQUNMQyxlQUFPO0FBQ0xDLG9CQUFVLE9BREw7QUFFTGhELGlCQUFPLFlBRkY7QUFHTGlELGlCQUFPLFlBSEY7QUFJTEMsa0JBQVEsYUFKSDtBQUtMQyxpQkFBTyxZQUxGO0FBTUxDLGVBQUssT0FOQTtBQU9MQyw0QkFBa0JDLGdDQUFlQyxTQVA1QjtBQVFMQywwQkFBZ0I7QUFSWCxTQURGO0FBV0xDLGNBQU07QUFDSlQsb0JBQVUsUUFETjtBQUVKaEQsaUJBQU8sV0FGSDtBQUdKaUQsaUJBQU8sV0FISDtBQUlKQyxrQkFBUSxZQUpKO0FBS0pDLGlCQUFPLFdBTEg7QUFNSkMsZUFBSyxNQU5EO0FBT0pDLDRCQUFrQkMsZ0NBQWVJLFFBUDdCO0FBUUpGLDBCQUFnQixhQVJaO0FBU0pHLHFCQUFXO0FBQUEsbUJBQVV4QixPQUFPSSxTQUFQLENBQWlCcUIsUUFBM0I7QUFBQTtBQVRQO0FBWEQsT0FBUDtBQXVCRDs7O0VBL0QyQ0MsbUI7O2tCQUF6QmhELGdCIiwiZmlsZSI6ImFnZ3JlZ2F0aW9uLWxheWVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE4IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IG1lbW9pemUgZnJvbSAnbG9kYXNoLm1lbW9pemUnO1xuaW1wb3J0IExheWVyIGZyb20gJy4vYmFzZS1sYXllcic7XG5pbXBvcnQge2hleFRvUmdifSBmcm9tICd1dGlscy9jb2xvci11dGlscyc7XG5pbXBvcnQge2FnZ3JlZ2F0ZX0gZnJvbSAndXRpbHMvYWdncmVnYXRlLXV0aWxzJztcbmltcG9ydCB7Q0hBTk5FTF9TQ0FMRVN9IGZyb20gJ2NvbnN0YW50cy9kZWZhdWx0LXNldHRpbmdzJztcblxuZXhwb3J0IGNvbnN0IHBvaW50UG9zQWNjZXNzb3IgPSAoe2xhdCwgbG5nfSkgPT4gZCA9PiBbXG4gIGRbbG5nLmZpZWxkSWR4XSxcbiAgZFtsYXQuZmllbGRJZHhdXG5dO1xuXG5leHBvcnQgY29uc3QgcG9pbnRQb3NSZXNvbHZlciA9ICh7bGF0LCBsbmd9KSA9PlxuICBgJHtsYXQuZmllbGRJZHh9LSR7bG5nLmZpZWxkSWR4fWA7XG5cbmV4cG9ydCBjb25zdCBnZXRWYWx1ZUFnZ3IgPSAoZmllbGQsIGFnZ3JlZ2F0aW9uKSA9PiBwb2ludHMgPT5cbiAgYWdncmVnYXRlKHBvaW50cy5tYXAocCA9PiBwW2ZpZWxkLnRhYmxlRmllbGRJbmRleCAtIDFdKSwgYWdncmVnYXRpb24pO1xuXG5jb25zdCBhZ2dyUmVzb2x2ZXIgPSAoZmllbGQsIGFnZ3JlZ2F0aW9uKSA9PiBgJHtmaWVsZC5uYW1lfS0ke2FnZ3JlZ2F0aW9ufWA7XG5cbmNvbnN0IGdldExheWVyQ29sb3JSYW5nZSA9IGNvbG9yUmFuZ2UgPT4gY29sb3JSYW5nZS5jb2xvcnMubWFwKGhleFRvUmdiKTtcblxuZXhwb3J0IGNvbnN0IGFnZ3JlZ2F0ZVJlcXVpcmVkQ29sdW1ucyA9IFsnbGF0JywgJ2xuZyddO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBZ2dyZWdhdGlvbkxheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuZ2V0UG9zaXRpb24gPSBtZW1vaXplKHBvaW50UG9zQWNjZXNzb3IsIHBvaW50UG9zUmVzb2x2ZXIpO1xuICAgIHRoaXMuZ2V0Q29sb3JWYWx1ZSA9IG1lbW9pemUoZ2V0VmFsdWVBZ2dyLCBhZ2dyUmVzb2x2ZXIpO1xuICAgIHRoaXMuZ2V0Q29sb3JSYW5nZSA9IG1lbW9pemUoZ2V0TGF5ZXJDb2xvclJhbmdlKTtcbiAgICB0aGlzLmdldEVsZXZhdGlvblZhbHVlID0gbWVtb2l6ZShnZXRWYWx1ZUFnZ3IsIGFnZ3JSZXNvbHZlcik7XG4gIH1cblxuICBnZXQgaXNBZ2dyZWdhdGVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZ2V0IHJlcXVpcmVkTGF5ZXJDb2x1bW5zKCkge1xuICAgIHJldHVybiBhZ2dyZWdhdGVSZXF1aXJlZENvbHVtbnM7XG4gIH1cblxuICBnZXQgY29sdW1uUGFpcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFBvaW50Q29sdW1uUGFpcnM7XG4gIH1cblxuICBnZXQgbm9uZUxheWVyRGF0YUFmZmVjdGluZ1Byb3BzKCkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5zdXBlci5ub25lTGF5ZXJEYXRhQWZmZWN0aW5nUHJvcHMsXG4gICAgICAnZW5hYmxlM2QnLFxuICAgICAgJ2NvbG9yUmFuZ2UnLFxuICAgICAgJ2NvbG9yU2NhbGUnLFxuICAgICAgJ2NvbG9yRG9tYWluJyxcbiAgICAgICdzaXplUmFuZ2UnLFxuICAgICAgJ3NpemVTY2FsZScsXG4gICAgICAnc2l6ZURvbWFpbicsXG4gICAgICAncGVyY2VudGlsZScsXG4gICAgICAnY292ZXJhZ2UnLFxuICAgICAgJ2VsZXZhdGlvblBlcmNlbnRpbGUnLFxuICAgICAgJ2VsZXZhdGlvblNjYWxlJ1xuICAgIF07XG4gIH1cblxuICBnZXQgdmlzdWFsQ2hhbm5lbHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHByb3BlcnR5OiAnY29sb3InLFxuICAgICAgICBmaWVsZDogJ2NvbG9yRmllbGQnLFxuICAgICAgICBzY2FsZTogJ2NvbG9yU2NhbGUnLFxuICAgICAgICBkb21haW46ICdjb2xvckRvbWFpbicsXG4gICAgICAgIHJhbmdlOiAnY29sb3JSYW5nZScsXG4gICAgICAgIGtleTogJ2NvbG9yJyxcbiAgICAgICAgY2hhbm5lbFNjYWxlVHlwZTogQ0hBTk5FTF9TQ0FMRVMuY29sb3JBZ2dyLFxuICAgICAgICBkZWZhdWx0TWVhc3VyZTogJ1BvaW50IENvdW50J1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgcHJvcGVydHk6ICdoZWlnaHQnLFxuICAgICAgICBmaWVsZDogJ3NpemVGaWVsZCcsXG4gICAgICAgIHNjYWxlOiAnc2l6ZVNjYWxlJyxcbiAgICAgICAgZG9tYWluOiAnc2l6ZURvbWFpbicsXG4gICAgICAgIHJhbmdlOiAnc2l6ZVJhbmdlJyxcbiAgICAgICAga2V5OiAnc2l6ZScsXG4gICAgICAgIGNoYW5uZWxTY2FsZVR5cGU6IENIQU5ORUxfU0NBTEVTLnNpemVBZ2dyLFxuICAgICAgICBkZWZhdWx0TWVhc3VyZTogJ1BvaW50IENvdW50JyxcbiAgICAgICAgY29uZGl0aW9uOiBjb25maWcgPT4gY29uZmlnLnZpc0NvbmZpZy5lbmFibGUzZFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBnZXRIb3ZlckRhdGEob2JqZWN0KSB7XG4gICAgLy8gcmV0dXJuIGFnZ3JlZ2F0ZWQgb2JqZWN0XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZ2dyZWdhdGlvbiBsYXllciBoYW5kbGVzIHZpc3VhbCBjaGFubmVsIGFnZ3JlZ2F0aW9uIGluc2lkZSBkZWNrLmdsIGxheWVyXG4gICAqL1xuICB1cGRhdGVMYXllclZpc3VhbENoYW5uZWwoe2RhdGEsIGFsbERhdGF9LCBjaGFubmVsKSB7XG4gICAgdGhpcy52YWxpZGF0ZVZpc3VhbENoYW5uZWwoY2hhbm5lbCk7XG4gIH1cblxuICAvKipcbiAgICogQWdncmVnYXRpb24gbGF5ZXIgaGFuZGxlcyB2aXN1YWwgY2hhbm5lbCBhZ2dyZWdhdGlvbiBpbnNpZGUgZGVjay5nbCBsYXllclxuICAgKi9cbiAgdXBkYXRlTGF5ZXJEb21haW4oZGF0YXNldCwgbmV3RmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1cGRhdGVMYXllck1ldGEoYWxsRGF0YSwgZ2V0UG9zaXRpb24pIHtcbiAgICAvLyBnZXQgYm91bmRzIGZyb20gcG9pbnRzXG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRQb2ludHNCb3VuZHMoYWxsRGF0YSwgZ2V0UG9zaXRpb24pO1xuXG4gICAgLy8gZ2V0IGxpZ2h0U2V0dGluZ3MgZnJvbSBwb2ludHNcbiAgICBjb25zdCBsaWdodFNldHRpbmdzID0gdGhpcy5nZXRMaWdodFNldHRpbmdzRnJvbUJvdW5kcyhib3VuZHMpO1xuXG4gICAgdGhpcy51cGRhdGVNZXRhKHtib3VuZHMsIGxpZ2h0U2V0dGluZ3N9KTtcbiAgfVxuXG4gIGZvcm1hdExheWVyRGF0YShfLCBhbGxEYXRhLCBmaWx0ZXJlZEluZGV4LCBvbGRMYXllckRhdGEsIG9wdCA9IHt9KSB7XG4gICAgY29uc3QgZ2V0UG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uKHRoaXMuY29uZmlnLmNvbHVtbnMpO1xuXG4gICAgaWYgKCFvbGRMYXllckRhdGEgfHwgb2xkTGF5ZXJEYXRhLmdldFBvc2l0aW9uICE9PSBnZXRQb3NpdGlvbikge1xuICAgICAgdGhpcy51cGRhdGVMYXllck1ldGEoYWxsRGF0YSwgZ2V0UG9zaXRpb24pO1xuICAgIH1cblxuICAgIGNvbnN0IGdldENvbG9yVmFsdWUgPSB0aGlzLmNvbmZpZy5jb2xvckZpZWxkXG4gICAgICA/IHRoaXMuZ2V0Q29sb3JWYWx1ZShcbiAgICAgICAgICB0aGlzLmNvbmZpZy5jb2xvckZpZWxkLFxuICAgICAgICAgIHRoaXMuY29uZmlnLnZpc0NvbmZpZy5jb2xvckFnZ3JlZ2F0aW9uXG4gICAgICAgIClcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgZ2V0RWxldmF0aW9uVmFsdWUgPSB0aGlzLmNvbmZpZy5zaXplRmllbGRcbiAgICAgID8gdGhpcy5nZXRFbGV2YXRpb25WYWx1ZShcbiAgICAgICAgICB0aGlzLmNvbmZpZy5zaXplRmllbGQsXG4gICAgICAgICAgdGhpcy5jb25maWcudmlzQ29uZmlnLnNpemVBZ2dyZWdhdGlvblxuICAgICAgICApXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGxldCBkYXRhO1xuICAgIGlmIChcbiAgICAgIG9sZExheWVyRGF0YSAmJlxuICAgICAgb2xkTGF5ZXJEYXRhLmRhdGEgJiZcbiAgICAgIG9wdC5zYW1lRGF0YSAmJlxuICAgICAgb2xkTGF5ZXJEYXRhLmdldFBvc2l0aW9uID09PSBnZXRQb3NpdGlvblxuICAgICkge1xuICAgICAgZGF0YSA9IG9sZExheWVyRGF0YS5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gZmlsdGVyZWRJbmRleC5tYXAoaSA9PiBhbGxEYXRhW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIGdldFBvc2l0aW9uLFxuICAgICAgLi4uKGdldENvbG9yVmFsdWUgPyB7Z2V0Q29sb3JWYWx1ZX0gOiB7fSksXG4gICAgICAuLi4oZ2V0RWxldmF0aW9uVmFsdWUgPyB7Z2V0RWxldmF0aW9uVmFsdWV9IDoge30pXG4gICAgfTtcbiAgfVxufVxuIl19