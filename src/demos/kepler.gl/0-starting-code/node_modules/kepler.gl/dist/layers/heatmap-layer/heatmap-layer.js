'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.heatmapVisConfigs = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _reselect = require('reselect');

var _defaultSettings = require('../../constants/default-settings');

var _colorUtils = require('../../utils/color-utils');

var _mapboxUtils = require('../mapbox-utils');

var _mapboxglLayer = require('../mapboxgl-layer');

var _mapboxglLayer2 = _interopRequireDefault(_mapboxglLayer);

var _heatmapLayerIcon = require('./heatmap-layer-icon');

var _heatmapLayerIcon2 = _interopRequireDefault(_heatmapLayerIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var MAX_ZOOM_LEVEL = 18;
var DEFAULT_OPACITY = .8;

var heatmapVisConfigs = exports.heatmapVisConfigs = {
  opacity: 'opacity',
  weight: 'weight',
  colorRange: 'colorRange',
  radius: 'heatmapRadius',
  weightRange: 'weight'
};

/**
 *
 * @param colorDomain
 * @param colorScale
 * @param visConfig
 * @return [
 *  0, "rgba(33,102,172,0)",
 *  0.2, "rgb(103,169,207)",
 *  0.4, "rgb(209,229,240)",
 *  0.6, "rgb(253,219,199)",
 *  0.8, "rgb(239,138,98)",
 *  1, "rgb(178,24,43)"
 * ]
 */
var heatmapDensity = function heatmapDensity(colorDomain, colorScale, visConfig) {

  // this is work around to deal with ordinal scale type.
  // I checked other aggregate layers and we don't deal with ordinal scales
  var scaleType = colorScale === _defaultSettings.SCALE_TYPES.ordinal ? _defaultSettings.SCALE_TYPES.quantize : colorScale;

  var scaleFunction = _defaultSettings.SCALE_FUNC[scaleType];

  var scale = scaleFunction().domain(colorDomain).range(visConfig.colorRange.colors);

  if (colorScale === _defaultSettings.SCALE_TYPES.ordinal) {
    scale.domain().map(function (level) {
      return [scale(level), 'rgb(' + (0, _colorUtils.hexToRgb)(scale(level)).join(',') + ')' // color
      ];
    });
  }

  return scale.range().reduce(function (bands, level) {
    var invert = scale.invertExtent(level);
    return [].concat((0, _toConsumableArray3.default)(bands), [invert[0], // first value in the range
    'rgb(' + (0, _colorUtils.hexToRgb)(level).join(',') + ')' // color
    ]);
  }, []);
};

var shouldRebuild = function shouldRebuild(sameData, sameConfig) {
  return !(sameData && sameConfig);
};

var HeatmapLayer = function (_MapboxGLLayer) {
  (0, _inherits3.default)(HeatmapLayer, _MapboxGLLayer);

  function HeatmapLayer(props) {
    (0, _classCallCheck3.default)(this, HeatmapLayer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (HeatmapLayer.__proto__ || Object.getPrototypeOf(HeatmapLayer)).call(this, props));

    _this.sameDataSelector = function (_ref) {
      var allData = _ref.allData,
          filteredIndex = _ref.filteredIndex,
          oldLayerData = _ref.oldLayerData,
          _ref$opt = _ref.opt,
          opt = _ref$opt === undefined ? {} : _ref$opt;

      return Boolean(oldLayerData && oldLayerData.data && oldLayerData.columns && opt.sameData);
    };

    _this.sameConfigSelector = function (_ref2) {
      var oldLayerData = _ref2.oldLayerData,
          config = _ref2.config;

      // columns must use the same filedIdx
      // this is a fast way to compare columns object
      var columns = config.columns,
          weightField = config.weightField;


      if (!oldLayerData) {
        return false;
      }

      var sameColumns = columns === oldLayerData.columns;
      var sameWeightField = weightField === oldLayerData.weightField;
      return sameColumns && sameWeightField;
    };

    _this.rebuildSelector = (0, _reselect.createSelector)(_this.sameDataSelector, _this.sameConfigSelector, function (sameData, sameColumns) {
      return !(sameData && sameColumns);
    });

    _this.datasetSelector = function (config) {
      return config.dataId;
    };

    _this.isVisibleSelector = function (config) {
      return config.isVisible;
    };

    _this.visConfigSelector = function (config) {
      return config.visConfig;
    };

    _this.weightFieldSelector = function (config) {
      return config.weightField;
    };

    _this.colorDomainSelector = function (config) {
      return config.colorDomain;
    };

    _this.colorScaleSelector = function (config) {
      return config.colorScale;
    };

    _this.radiusSelector = function (config) {
      return config.visConfig.radius;
    };

    _this.computeHeatmapConfiguration = (0, _reselect.createSelector)(_this.datasetSelector, _this.isVisibleSelector, _this.visConfigSelector, _this.weightFieldSelector, _this.colorDomainSelector, _this.colorScaleSelector, _this.radiusSelector, function (datasetId, isVisible, visConfig, weightField, colorDomain, colorScale, radius) {
      // TODO: improve using setPaintProperty
      return {
        type: 'heatmap',
        source: datasetId,
        layout: {
          visibility: isVisible ? 'visible' : 'none'
        },
        maxzoom: MAX_ZOOM_LEVEL,
        paint: {
          'heatmap-weight': weightField ? ['interpolate', ['linear'], ['get', weightField.name], 0, 0, MAX_ZOOM_LEVEL, visConfig.weight] : 1,
          'heatmap-intensity': ['interpolate', ['linear'], ['zoom'], 0, 1, MAX_ZOOM_LEVEL, 3],
          'heatmap-color': ['interpolate', ['linear'], ['heatmap-density']].concat((0, _toConsumableArray3.default)(heatmapDensity(colorDomain, colorScale, visConfig))),
          'heatmap-radius': ['interpolate', ['linear'], ['zoom'], 0, 2, MAX_ZOOM_LEVEL, radius // radius
          ],
          'heatmap-opacity': visConfig.opacity || DEFAULT_OPACITY
        }
      };
    });

    _this.registerVisConfig(heatmapVisConfigs);
    return _this;
  }

  (0, _createClass3.default)(HeatmapLayer, [{
    key: 'getDefaultLayerConfig',
    value: function getDefaultLayerConfig() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return (0, _extends3.default)({}, (0, _get3.default)(HeatmapLayer.prototype.__proto__ || Object.getPrototypeOf(HeatmapLayer.prototype), 'getDefaultLayerConfig', this).call(this, props), {
        // add height visual channel
        weightField: null,
        weightDomain: [0, 1],
        weightRange: [0, 1],
        weightScale: 'linear'
      });
    }
  }, {
    key: 'formatLayerData',
    value: function formatLayerData(_, allData, filteredIndex, oldLayerData) {
      var opt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

      var options = {
        allData: allData,
        filteredIndex: filteredIndex,
        oldLayerData: oldLayerData,
        opt: opt,
        config: this.config
      };

      var weightField = this.config.weightField;


      var data = !shouldRebuild(this.sameDataSelector(options), this.sameConfigSelector(options)) ? null : (0, _mapboxUtils.geojsonFromPoints)(allData, filteredIndex, this.config.columns, weightField ? [weightField] : []);

      var newConfig = this.computeHeatmapConfiguration(this.config);
      newConfig.id = this.id;

      return {
        columns: this.config.columns,
        config: newConfig,
        data: data,
        weightField: weightField
      };
    }
  }, {
    key: 'type',
    get: function get() {
      return 'heatmap';
    }
  }, {
    key: 'visualChannels',
    get: function get() {
      return (0, _extends3.default)({}, (0, _get3.default)(HeatmapLayer.prototype.__proto__ || Object.getPrototypeOf(HeatmapLayer.prototype), 'visualChannels', this), {
        weight: {
          property: 'weight',
          field: 'weightField',
          scale: 'weightScale',
          domain: 'weightDomain',
          range: 'weightRange',
          key: 'weight',
          channelScaleType: _defaultSettings.CHANNEL_SCALES.sizeAggr
        }
      });
    }
  }, {
    key: 'layerIcon',
    get: function get() {
      return _heatmapLayerIcon2.default;
    }
  }]);
  return HeatmapLayer;
}(_mapboxglLayer2.default);

exports.default = HeatmapLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9sYXllcnMvaGVhdG1hcC1sYXllci9oZWF0bWFwLWxheWVyLmpzIl0sIm5hbWVzIjpbIk1BWF9aT09NX0xFVkVMIiwiREVGQVVMVF9PUEFDSVRZIiwiaGVhdG1hcFZpc0NvbmZpZ3MiLCJvcGFjaXR5Iiwid2VpZ2h0IiwiY29sb3JSYW5nZSIsInJhZGl1cyIsIndlaWdodFJhbmdlIiwiaGVhdG1hcERlbnNpdHkiLCJjb2xvckRvbWFpbiIsImNvbG9yU2NhbGUiLCJ2aXNDb25maWciLCJzY2FsZVR5cGUiLCJTQ0FMRV9UWVBFUyIsIm9yZGluYWwiLCJxdWFudGl6ZSIsInNjYWxlRnVuY3Rpb24iLCJTQ0FMRV9GVU5DIiwic2NhbGUiLCJkb21haW4iLCJyYW5nZSIsImNvbG9ycyIsIm1hcCIsImxldmVsIiwiam9pbiIsInJlZHVjZSIsImJhbmRzIiwiaW52ZXJ0IiwiaW52ZXJ0RXh0ZW50Iiwic2hvdWxkUmVidWlsZCIsInNhbWVEYXRhIiwic2FtZUNvbmZpZyIsIkhlYXRtYXBMYXllciIsInByb3BzIiwic2FtZURhdGFTZWxlY3RvciIsImFsbERhdGEiLCJmaWx0ZXJlZEluZGV4Iiwib2xkTGF5ZXJEYXRhIiwib3B0IiwiQm9vbGVhbiIsImRhdGEiLCJjb2x1bW5zIiwic2FtZUNvbmZpZ1NlbGVjdG9yIiwiY29uZmlnIiwid2VpZ2h0RmllbGQiLCJzYW1lQ29sdW1ucyIsInNhbWVXZWlnaHRGaWVsZCIsInJlYnVpbGRTZWxlY3RvciIsImRhdGFzZXRTZWxlY3RvciIsImRhdGFJZCIsImlzVmlzaWJsZVNlbGVjdG9yIiwiaXNWaXNpYmxlIiwidmlzQ29uZmlnU2VsZWN0b3IiLCJ3ZWlnaHRGaWVsZFNlbGVjdG9yIiwiY29sb3JEb21haW5TZWxlY3RvciIsImNvbG9yU2NhbGVTZWxlY3RvciIsInJhZGl1c1NlbGVjdG9yIiwiY29tcHV0ZUhlYXRtYXBDb25maWd1cmF0aW9uIiwiZGF0YXNldElkIiwidHlwZSIsInNvdXJjZSIsImxheW91dCIsInZpc2liaWxpdHkiLCJtYXh6b29tIiwicGFpbnQiLCJuYW1lIiwicmVnaXN0ZXJWaXNDb25maWciLCJ3ZWlnaHREb21haW4iLCJ3ZWlnaHRTY2FsZSIsIl8iLCJvcHRpb25zIiwibmV3Q29uZmlnIiwiaWQiLCJwcm9wZXJ0eSIsImZpZWxkIiwia2V5IiwiY2hhbm5lbFNjYWxlVHlwZSIsIkNIQU5ORUxfU0NBTEVTIiwic2l6ZUFnZ3IiLCJIZWF0bWFwTGF5ZXJJY29uIiwiTWFwYm94R0xMYXllciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVNBLElBQU1BLGlCQUFpQixFQUF2QjtBQUNBLElBQU1DLGtCQUFrQixFQUF4Qjs7QUFFTyxJQUFNQyxnREFBb0I7QUFDL0JDLFdBQVMsU0FEc0I7QUFFL0JDLFVBQVEsUUFGdUI7QUFHL0JDLGNBQVksWUFIbUI7QUFJL0JDLFVBQVEsZUFKdUI7QUFLL0JDLGVBQWE7QUFMa0IsQ0FBMUI7O0FBUVA7Ozs7Ozs7Ozs7Ozs7O0FBY0EsSUFBTUMsaUJBQWlCLFNBQWpCQSxjQUFpQixDQUFDQyxXQUFELEVBQWNDLFVBQWQsRUFBMEJDLFNBQTFCLEVBQXdDOztBQUU3RDtBQUNBO0FBQ0EsTUFBTUMsWUFBYUYsZUFBZUcsNkJBQVlDLE9BQTNCLEdBQ2pCRCw2QkFBWUUsUUFESyxHQUNNTCxVQUR6Qjs7QUFHQSxNQUFNTSxnQkFBZ0JDLDRCQUFXTCxTQUFYLENBQXRCOztBQUVBLE1BQU1NLFFBQVFGLGdCQUNYRyxNQURXLENBQ0pWLFdBREksRUFFWFcsS0FGVyxDQUVMVCxVQUFVTixVQUFWLENBQXFCZ0IsTUFGaEIsQ0FBZDs7QUFJQSxNQUFJWCxlQUFlRyw2QkFBWUMs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QUFRNEIsU0FGSDtBQUdML0Isa0JBSEs7QUFJTEk7QUFKSyxPQUFQO0FBTUQ7Ozt3QkF4SlU7QUFDVCxhQUFPLFNBQVA7QUFDRDs7O3dCQUVvQjtBQUNuQjtBQUVFeEMsZ0JBQVE7QUFDTnFFLG9CQUFVLFFBREo7QUFFTkMsaUJBQU8sYUFGRDtBQUdOeEQsaUJBQU8sYUFIRDtBQUlOQyxrQkFBUSxjQUpGO0FBS05DLGlCQUFPLGFBTEQ7QUFNTnVELGVBQUssUUFOQztBQU9OQyw0QkFBa0JDLGdDQUFlQztBQVAzQjtBQUZWO0FBWUQ7Ozt3QkFFZTtBQUNkLGFBQU9DLDBCQUFQO0FBQ0Q7OztFQTNCd0JDLHVCOztrQkFpS1poRCxZIiwiZmlsZSI6ImhlYXRtYXAtbGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTggVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge2NyZWF0ZVNlbGVjdG9yfSBmcm9tICdyZXNlbGVjdCc7XG5pbXBvcnQge0NIQU5ORUxfU0NBTEVTLCBTQ0FMRV9GVU5DLCBTQ0FMRV9UWVBFU30gZnJvbSAnY29uc3RhbnRzL2RlZmF1bHQtc2V0dGluZ3MnO1xuaW1wb3J0IHtoZXhUb1JnYn0gZnJvbSAndXRpbHMvY29sb3ItdXRpbHMnO1xuaW1wb3J0IHtnZW9qc29uRnJvbVBvaW50c30gZnJvbSAnLi4vbWFwYm94LXV0aWxzJztcbmltcG9ydCBNYXBib3hHTExheWVyIGZyb20gJy4uL21hcGJveGdsLWxheWVyJztcbmltcG9ydCBIZWF0bWFwTGF5ZXJJY29uIGZyb20gJy4vaGVhdG1hcC1sYXllci1pY29uJztcblxuY29uc3QgTUFYX1pPT01fTEVWRUwgPSAxODtcbmNvbnN0IERFRkFVTFRfT1BBQ0lUWSA9IC44O1xuXG5leHBvcnQgY29uc3QgaGVhdG1hcFZpc0NvbmZpZ3MgPSB7XG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgd2VpZ2h0OiAnd2VpZ2h0JyxcbiAgY29sb3JSYW5nZTogJ2NvbG9yUmFuZ2UnLFxuICByYWRpdXM6ICdoZWF0bWFwUmFkaXVzJyxcbiAgd2VpZ2h0UmFuZ2U6ICd3ZWlnaHQnXG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gY29sb3JEb21haW5cbiAqIEBwYXJhbSBjb2xvclNjYWxlXG4gKiBAcGFyYW0gdmlzQ29uZmlnXG4gKiBAcmV0dXJuIFtcbiAqICAwLCBcInJnYmEoMzMsMTAyLDE3MiwwKVwiLFxuICogIDAuMiwgXCJyZ2IoMTAzLDE2OSwyMDcpXCIsXG4gKiAgMC40LCBcInJnYigyMDksMjI5LDI0MClcIixcbiAqICAwLjYsIFwicmdiKDI1MywyMTksMTk5KVwiLFxuICogIDAuOCwgXCJyZ2IoMjM5LDEzOCw5OClcIixcbiAqICAxLCBcInJnYigxNzgsMjQsNDMpXCJcbiAqIF1cbiAqL1xuY29uc3QgaGVhdG1hcERlbnNpdHkgPSAoY29sb3JEb21haW4sIGNvbG9yU2NhbGUsIHZpc0NvbmZpZykgPT4ge1xuXG4gIC8vIHRoaXMgaXMgd29yayBhcm91bmQgdG8gZGVhbCB3aXRoIG9yZGluYWwgc2NhbGUgdHlwZS5cbiAgLy8gSSBjaGVja2VkIG90aGVyIGFnZ3JlZ2F0ZSBsYXllcnMgYW5kIHdlIGRvbid0IGRlYWwgd2l0aCBvcmRpbmFsIHNjYWxlc1xuICBjb25zdCBzY2FsZVR5cGUgPSAgY29sb3JTY2FsZSA9PT0gU0NBTEVfVFlQRVMub3JkaW5hbCA/XG4gICAgU0NBTEVfVFlQRVMucXVhbnRpemUgOiBjb2xvclNjYWxlO1xuXG4gIGNvbnN0IHNjYWxlRnVuY3Rpb24gPSBTQ0FMRV9GVU5DW3NjYWxlVHlwZV07XG5cbiAgY29uc3Qgc2NhbGUgPSBzY2FsZUZ1bmN0aW9uKClcbiAgICAuZG9tYWluKGNvbG9yRG9tYWluKVxuICAgIC5yYW5nZSh2aXNDb25maWcuY29sb3JSYW5nZS5jb2xvcnMpO1xuXG4gIGlmIChjb2xvclNjYWxlID09PSBTQ0FMRV9UWVBFUy5vcmRpbmFsKSB7XG4gICAgc2NhbGUuZG9tYWluKCkubWFwKGxldmVsID0+IHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNjYWxlKGxldmVsKSxcbiAgICAgICAgYHJnYigke2hleFRvUmdiKHNjYWxlKGxldmVsKSkuam9pbignLCcpfSlgIC8vIGNvbG9yXG4gICAgICBdO1xuICAgIH0pXG4gIH1cblxuICByZXR1cm4gc2NhbGUucmFuZ2UoKS5yZWR1Y2UoKGJhbmRzLCBsZXZlbCkgPT4ge1xuICAgIGNvbnN0IGludmVydCA9IHNjYWxlLmludmVydEV4dGVudChsZXZlbCk7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLmJhbmRzLFxuICAgICAgaW52ZXJ0WzBdLCAvLyBmaXJzdCB2YWx1ZSBpbiB0aGUgcmFuZ2VcbiAgICAgIGByZ2IoJHtoZXhUb1JnYihsZXZlbCkuam9pbignLCcpfSlgIC8vIGNvbG9yXG4gICAgXVxuICB9LCBbXSk7XG59O1xuXG5jb25zdCBzaG91bGRSZWJ1aWxkID0gKHNhbWVEYXRhLCBzYW1lQ29uZmlnKSA9PiAhKHNhbWVEYXRhICYmIHNhbWVDb25maWcpO1xuXG5jbGFzcyBIZWF0bWFwTGF5ZXIgZXh0ZW5kcyBNYXBib3hHTExheWVyIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5yZWdpc3RlclZpc0NvbmZpZyhoZWF0bWFwVmlzQ29uZmlncyk7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2hlYXRtYXAnO1xuICB9XG5cbiAgZ2V0IHZpc3VhbENoYW5uZWxzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci52aXN1YWxDaGFubmVscyxcbiAgICAgIHdlaWdodDoge1xuICAgICAgICBwcm9wZXJ0eTogJ3dlaWdodCcsXG4gICAgICAgIGZpZWxkOiAnd2VpZ2h0RmllbGQnLFxuICAgICAgICBzY2FsZTogJ3dlaWdodFNjYWxlJyxcbiAgICAgICAgZG9tYWluOiAnd2VpZ2h0RG9tYWluJyxcbiAgICAgICAgcmFuZ2U6ICd3ZWlnaHRSYW5nZScsXG4gICAgICAgIGtleTogJ3dlaWdodCcsXG4gICAgICAgIGNoYW5uZWxTY2FsZVR5cGU6IENIQU5ORUxfU0NBTEVTLnNpemVBZ2dyXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGdldCBsYXllckljb24oKSB7XG4gICAgcmV0dXJuIEhlYXRtYXBMYXllckljb247XG4gIH1cblxuICBnZXREZWZhdWx0TGF5ZXJDb25maWcocHJvcHMgPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXREZWZhdWx0TGF5ZXJDb25maWcocHJvcHMpLFxuICAgICAgLy8gYWRkIGhlaWdodCB2aXN1YWwgY2hhbm5lbFxuICAgICAgd2VpZ2h0RmllbGQ6IG51bGwsXG4gICAgICB3ZWlnaHREb21haW46IFswLCAxXSxcbiAgICAgIHdlaWdodFJhbmdlOiBbMCwgMV0sXG4gICAgICB3ZWlnaHRTY2FsZTogJ2xpbmVhcidcbiAgICB9XG4gIH1cblxuICBzYW1lRGF0YVNlbGVjdG9yID0gKHthbGxEYXRhLCBmaWx0ZXJlZEluZGV4LCBvbGRMYXllckRhdGEsIG9wdCA9IHt9fSkgPT4ge1xuICAgIHJldHVybiBCb29sZWFuKG9sZExheWVyRGF0YSAmJlxuICAgICAgb2xkTGF5ZXJEYXRhLmRhdGEgJiYgb2xkTGF5ZXJEYXRhLmNvbHVtbnMgJiZcbiAgICAgIG9wdC5zYW1lRGF0YVxuICAgICk7XG4gIH07XG5cbiAgc2FtZUNvbmZpZ1NlbGVjdG9yID0gKHtvbGRMYXllckRhdGEsIGNvbmZpZ30pID0+IHtcbiAgICAvLyBjb2x1bW5zIG11c3QgdXNlIHRoZSBzYW1lIGZpbGVkSWR4XG4gICAgLy8gdGhpcyBpcyBhIGZhc3Qgd2F5IHRvIGNvbXBhcmUgY29sdW1ucyBvYmplY3RcbiAgICBjb25zdCB7XG4gICAgICBjb2x1bW5zLFxuICAgICAgd2VpZ2h0RmllbGRcbiAgICB9ID0gY29uZmlnO1xuXG4gICAgaWYgKCFvbGRMYXllckRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBzYW1lQ29sdW1ucyA9IGNvbHVtbnMgPT09IG9sZExheWVyRGF0YS5jb2x1bW5zO1xuICAgIGNvbnN0IHNhbWVXZWlnaHRGaWVsZCA9IHdlaWdodEZpZWxkID09PSBvbGRMYXllckRhdGEud2VpZ2h0RmllbGQ7XG4gICAgcmV0dXJuIHNhbWVDb2x1bW5zICYmIHNhbWVXZWlnaHRGaWVsZDtcbiAgfTtcblxuICByZWJ1aWxkU2VsZWN0b3IgPSBjcmVhdGVTZWxlY3RvcihcbiAgICB0aGlzLnNhbWVEYXRhU2VsZWN0b3IsXG4gICAgdGhpcy5zYW1lQ29uZmlnU2VsZWN0b3IsXG4gICAgKHNhbWVEYXRhLCBzYW1lQ29sdW1ucykgPT4gIShzYW1lRGF0YSAmJiBzYW1lQ29sdW1ucylcbiAgKTtcblxuICBkYXRhc2V0U2VsZWN0b3IgPSBjb25maWcgPT4gY29uZmlnLmRhdGFJZDtcbiAgaXNWaXNpYmxlU2VsZWN0b3IgPSBjb25maWcgPT4gY29uZmlnLmlzVmlzaWJsZTtcbiAgdmlzQ29uZmlnU2VsZWN0b3IgPSBjb25maWcgPT4gY29uZmlnLnZpc0NvbmZpZztcbiAgd2VpZ2h0RmllbGRTZWxlY3RvciA9IGNvbmZpZyA9PiBjb25maWcud2VpZ2h0RmllbGQ7XG4gIGNvbG9yRG9tYWluU2VsZWN0b3IgPSBjb25maWcgPT4gY29uZmlnLmNvbG9yRG9tYWluO1xuICBjb2xvclNjYWxlU2VsZWN0b3IgPSBjb25maWcgPT4gY29uZmlnLmNvbG9yU2NhbGU7XG4gIHJhZGl1c1NlbGVjdG9yID0gY29uZmlnID0+IGNvbmZpZy52aXNDb25maWcucmFkaXVzO1xuXG4gIGNvbXB1dGVIZWF0bWFwQ29uZmlndXJhdGlvbiA9IGNyZWF0ZVNlbGVjdG9yKFxuICAgIHRoaXMuZGF0YXNldFNlbGVjdG9yLFxuICAgIHRoaXMuaXNWaXNpYmxlU2VsZWN0b3IsXG4gICAgdGhpcy52aXNDb25maWdTZWxlY3RvcixcbiAgICB0aGlzLndlaWdodEZpZWxkU2VsZWN0b3IsXG4gICAgdGhpcy5jb2xvckRvbWFpblNlbGVjdG9yLFxuICAgIHRoaXMuY29sb3JTY2FsZVNlbGVjdG9yLFxuICAgIHRoaXMucmFkaXVzU2VsZWN0b3IsXG4gICAgKGRhdGFzZXRJZCwgaXNWaXNpYmxlLCB2aXNDb25maWcsIHdlaWdodEZpZWxkLCBjb2xvckRvbWFpbiwgY29sb3JTY2FsZSwgcmFkaXVzKSA9PiB7XG4gICAgICAvLyBUT0RPOiBpbXByb3ZlIHVzaW5nIHNldFBhaW50UHJvcGVydHlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdoZWF0bWFwJyxcbiAgICAgICAgc291cmNlOiBkYXRhc2V0SWQsXG4gICAgICAgIGxheW91dDoge1xuICAgICAgICAgIHZpc2liaWxpdHk6IGlzVmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdub25lJ1xuICAgICAgICB9LFxuICAgICAgICBtYXh6b29tOiBNQVhfWk9PTV9MRVZFTCxcbiAgICAgICAgcGFpbnQ6IHtcbiAgICAgICAgICAnaGVhdG1hcC13ZWlnaHQnOiB3ZWlnaHRGaWVsZCA/IFtcbiAgICAgICAgICAgICdpbnRlcnBvbGF0ZScsXG4gICAgICAgICAgICBbJ2xpbmVhciddLFxuICAgICAgICAgICAgWydnZXQnLCB3ZWlnaHRGaWVsZC5uYW1lXSxcbiAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICBNQVhfWk9PTV9MRVZFTCwgdmlzQ29uZmlnLndlaWdodFxuICAgICAgICAgIF0gOiAxLFxuICAgICAgICAgICdoZWF0bWFwLWludGVuc2l0eSc6IFtcbiAgICAgICAgICAgICdpbnRlcnBvbGF0ZScsXG4gICAgICAgICAgICBbJ2xpbmVhciddLFxuICAgICAgICAgICAgWyd6b29tJ10sXG4gICAgICAgICAgICAwLCAxLFxuICAgICAgICAgICAgTUFYX1pPT01fTEVWRUwsIDNcbiAgICAgICAgICBdLFxuICAgICAgICAgICdoZWF0bWFwLWNvbG9yJzogW1xuICAgICAgICAgICAgJ2ludGVycG9sYXRlJyxcbiAgICAgICAgICAgIFsnbGluZWFyJ10sXG4gICAgICAgICAgICBbJ2hlYXRtYXAtZGVuc2l0eSddLFxuICAgICAgICAgICAgLi4uaGVhdG1hcERlbnNpdHkoY29sb3JEb21haW4sIGNvbG9yU2NhbGUsIHZpc0NvbmZpZylcbiAgICAgICAgICBdLFxuICAgICAgICAgICdoZWF0bWFwLXJhZGl1cyc6IFtcbiAgICAgICAgICAgICdpbnRlcnBvbGF0ZScsXG4gICAgICAgICAgICBbJ2xpbmVhciddLFxuICAgICAgICAgICAgWyd6b29tJ10sXG4gICAgICAgICAgICAwLCAyLFxuICAgICAgICAgICAgTUFYX1pPT01fTEVWRUwsIHJhZGl1cyAvLyByYWRpdXNcbiAgICAgICAgICBdLFxuICAgICAgICAgICdoZWF0bWFwLW9wYWNpdHknOiB2aXNDb25maWcub3BhY2l0eSB8fCBERUZBVUxUX09QQUNJVFlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICk7XG5cbiAgZm9ybWF0TGF5ZXJEYXRhKF8sIGFsbERhdGEsIGZpbHRlcmVkSW5kZXgsIG9sZExheWVyRGF0YSwgb3B0ID0ge30pIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgYWxsRGF0YSxcbiAgICAgIGZpbHRlcmVkSW5kZXgsXG4gICAgICBvbGRMYXllckRhdGEsXG4gICAgICBvcHQsXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnXG4gICAgfTtcblxuICAgIGNvbnN0IHt3ZWlnaHRGaWVsZH0gPSB0aGlzLmNvbmZpZztcblxuICAgIGNvbnN0IGRhdGEgPSAhc2hvdWxkUmVidWlsZCh0aGlzLnNhbWVEYXRhU2VsZWN0b3Iob3B0aW9ucyksIHRoaXMuc2FtZUNvbmZpZ1NlbGVjdG9yKG9wdGlvbnMpKSA/XG4gICAgICBudWxsIDpcbiAgICAgIGdlb2pzb25Gcm9tUG9pbnRzKFxuICAgICAgICBhbGxEYXRhLFxuICAgICAgICBmaWx0ZXJlZEluZGV4LFxuICAgICAgICB0aGlzLmNvbmZpZy5jb2x1bW5zLFxuICAgICAgICB3ZWlnaHRGaWVsZCA/IFt3ZWlnaHRGaWVsZF0gOiBbXVxuICAgICAgKTtcblxuICAgIGNvbnN0IG5ld0NvbmZpZyA9IHRoaXMuY29tcHV0ZUhlYXRtYXBDb25maWd1cmF0aW9uKHRoaXMuY29uZmlnKTtcbiAgICBuZXdDb25maWcuaWQgPSB0aGlzLmlkO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbnM6IHRoaXMuY29uZmlnLmNvbHVtbnMsXG4gICAgICBjb25maWc6IG5ld0NvbmZpZyxcbiAgICAgIGRhdGEsXG4gICAgICB3ZWlnaHRGaWVsZFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSGVhdG1hcExheWVyO1xuIl19