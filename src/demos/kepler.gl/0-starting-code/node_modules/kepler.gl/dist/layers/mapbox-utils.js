'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _extends5 = require('babel-runtime/helpers/extends');

var _extends6 = _interopRequireDefault(_extends5);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports.generateMapboxLayers = generateMapboxLayers;
exports.updateMapboxLayers = updateMapboxLayers;
exports.geojsonFromPoints = geojsonFromPoints;

var _baseLayer = require('./base-layer');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This function will convert layers to mapbox layers
 * @param layers the layers to be converted
 * @param layerData extra layer information
 * @param layerOrder the order by which we should convert layers
 * @returns {*}
 */
function generateMapboxLayers() {
  var layers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var layerData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var layerOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (layerData.length > 0) {
    return layerOrder.slice().reverse().reduce(function (overlays, idx) {
      var layer = layers[idx];

      return layer.overlayType !== _baseLayer.OVERLAY_TYPE.mapboxgl ? overlays : [].concat((0, _toConsumableArray3.default)(overlays), [{
        id: layer.id,
        data: layerData[idx].data,
        config: layerData[idx].config,
        datasetId: layer.config.dataId
      }]);
    }, []);
  }

  return [];
} // Copyright (c) 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

;

/**
 * Update mapbox layers on the given map
 * @param map
 * @param newLayers Array of new mapbox layers to be displayed
 * @param oldLayers Map of the old layers to be compare with the current ones to detect deleted layers
 *                  {layerId: datasetId}
 * @param mapLayers carries information about split map view
 */
function updateMapboxLayers(map) {
  var newLayers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var oldLayers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var mapLayers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var opt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : { force: true };

  // delete non existing layers
  if (oldLayers) {
    var oldLayersKeys = Object.keys(oldLayers);
    if (newLayers.length === 0 && oldLayersKeys.length > 0) {
      oldLayersKeys.forEach(function (layerId) {
        return map.removeLayer(layerId);
      });
    } else {
      // remove layers
      var currentLayersIds = newLayers.reduce(function (final, layer) {
        return (0, _extends6.default)({}, final, (0, _defineProperty3.default)({}, layer.id, true));
      }, {});

      var layersToDelete = oldLayersKeys.reduce(function (final, layerId) {
        // if layer doesn't exists anymore
        if (!currentLayersIds[layerId]) {
          return (0, _extends6.default)({}, final, (0, _defineProperty3.default)({}, layerId, oldLayers[layerId]));
        }
        return final;
      }, []);
      Object.keys(layersToDelete).forEach(function (layerId) {
        return map.removeLayer(layerId);
      });
    }
  }

  // insert or update newlayer
  newLayers.forEach(function (overlay) {
    var layerId = overlay.id,
        config = overlay.config,
        data = overlay.data,
        datasetId = overlay.datasetId;

    if (!data && !config) {
      return;
    }
    var isAvailableAndVisible = !(mapLayers && mapLayers[layerId]) || mapLayers[layerId].isVisible;
    // checking if source already exists

    if (data && isAvailableAndVisible) {
      var source = map.getSource(datasetId);
      if (!source) {
        map.addSource(datasetId, {
          type: 'geojson',
          data: data
        });
      } else {
        source.setData(data);
      }
    }

    var oldConfig = oldLayers[layerId];
    var mapboxLayer = map.getLayer(layerId);
    // compare with previous configs

    if (!oldConfig || oldConfig !== config || !mapboxLayer || opt.force) {
      // check if layer already is set
      // remove it if exists
      if (mapboxLayer) {
        map.removeLayer(layerId);
      }
      // add if visible and available
      if (isAvailableAndVisible) {
        map.addLayer(config);
      }
    }
  });
  // TODO: think about removing sources
};

/**
 *
 * @param points
 * @param columns {
 * lat: {fieldIdx},
 * lng: {fieldIdx},
 * alt: {fieldIdx}
 * }
 * @param properties [{label: {fieldIdx}]
 * @returns {{type: string, properties: {}, features: {type: string, properties: {}, geometry: {type: string, coordinates: *[]}}[]}}
 */
function geojsonFromPoints() {
  var allData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var filteredIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var columns = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var properties = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  return {
    type: 'FeatureCollection',
    features: filteredIndex.map(function (index) {
      return allData[index];
    }).map(function (point) {
      return {
        type: 'Feature',
        properties: properties.reduce(function (final, property) {
          return (0, _extends6.default)({}, final, (0, _defineProperty3.default)({}, property.name, point[property.tableFieldIndex - 1]));
        }, {}),
        geometry: {
          type: 'Point',
          coordinates: [columns.lng ? point[columns.lng.fieldIdx] : null, // lng
          columns.lat ? point[columns.lat.fieldIdx] : null, // lat
          columns.altitude ? point[columns.altitude.fieldIdx] : 0 // altitude
          ]
        }
      };
    })
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYXllcnMvbWFwYm94LXV0aWxzLmpzIl0sIm5hbWVzIjpbImdlbmVyYXRlTWFwYm94TGF5ZXJzIiwidXBkYXRlTWFwYm94TGF5ZXJzIiwiZ2VvanNvbkZyb21Qb2ludHMiLCJsYXllcnMiLCJsYXllckRhdGEiLCJsYXllck9yZGVyIiwibGVuZ3RoIiwic2xpY2UiLCJyZXZlcnNlIiwicmVkdWNlIiwib3ZlcmxheXMiLCJpZHgiLCJsYXllciIsIm92ZXJsYXlUeXBlIiwiT1ZFUkxBWV9UWVBFIiwibWFwYm94Z2wiLCJpZCIsImRhdGEiLCJjb25maWciLCJkYXRhc2V0SWQiLCJkYXRhSWQiLCJtYXAiLCJuZXdMYXllcnMiLCJvbGRMYXllcnMiLCJtYXBMYXllcnMiLCJvcHQiLCJmb3JjZSIsIm9sZExheWVyc0tleXMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInJlbW92ZUxheWVyIiwibGF5ZXJJZCIsImN1cnJlbnRMYXllcnNJZHMiLCJmaW5hbCIsImxheWVyc1RvRGVsZXRlIiwib3ZlcmxheSIsImlzQXZhaWxhYmxlQW5kVmlzaWJsZSIsImlzVmlzaWJsZSIsInNvdXJjZSIsImdldFNvdXJjZSIsImFkZFNvdXJjZSIsInR5cGUiLCJzZXREYXRhIiwib2xkQ29uZmlnIiwibWFwYm94TGF5ZXIiLCJnZXRMYXllciIsImFkZExheWVyIiwiYWxsRGF0YSIsImZpbHRlcmVkSW5kZXgiLCJjb2x1bW5zIiwicHJvcGVydGllcyIsImZlYXR1cmVzIiwiaW5kZXgiLCJwcm9wZXJ0eSIsIm5hbWUiLCJwb2ludCIsInRhYmxlRmllbGRJbmRleCIsImdlb21ldHJ5IiwiY29vcmRpbmF0ZXMiLCJsbmciLCJmaWVsZElkeCIsImxhdCIsImFsdGl0dWRlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7UUE2QmdCQSxvQixHQUFBQSxvQjtRQWdDQUMsa0IsR0FBQUEsa0I7UUFnRkFDLGlCLEdBQUFBLGlCOztBQXpIaEI7Ozs7QUFFQTs7Ozs7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SyxLQUFSLENBQVQ7QUFBQSxLQUFsQixFQUEyQ2hDLEdBQTNDLENBQStDO0FBQUEsYUFBVTtBQUNqRXFCLGNBQU0sU0FEMkQ7QUFFakVTLG9CQUFZQSxXQUFXMUMsTUFBWCxDQUFrQixVQUFDeUIsS0FBRCxFQUFRb0IsUUFBUjtBQUFBLDRDQUN6QnBCLEtBRHlCLG9DQUUzQm9CLFNBQVNDLElBRmtCLEVBRVhDLE1BQU1GLFNBQVNHLGVBQVQsR0FBMkIsQ0FBakMsQ0FGVztBQUFBLFNBQWxCLEVBR1IsRUFIUSxDQUZxRDtBQU1qRUMsa0JBQVU7QUFDUmhCLGdCQUFNLE9BREU7QUFFUmlCLHVCQUFhLENBQ1hULFFBQVFVLEdBQVIsR0FBY0osTUFBTU4sUUFBUVUsR0FBUixDQUFZQyxRQUFsQixDQUFkLEdBQTRDLElBRGpDLEVBQ3VDO0FBQ2xEWCxrQkFBUVksR0FBUixHQUFjTixNQUFNTixRQUFRWSxHQUFSLENBQVlELFFBQWxCLENBQWQsR0FBNEMsSUFGakMsRUFFdUM7QUFDbERYLGtCQUFRYSxRQUFSLEdBQW1CUCxNQUFNTixRQUFRYSxRQUFSLENBQWlCRixRQUF2QixDQUFuQixHQUFzRCxDQUgzQyxDQUc2QztBQUg3QztBQUZMO0FBTnVELE9BQVY7QUFBQSxLQUEvQztBQUZMLEdBQVA7QUFrQkQiLCJmaWxlIjoibWFwYm94LXV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE4IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtPVkVSTEFZX1RZUEV9IGZyb20gJy4vYmFzZS1sYXllcic7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgbGF5ZXJzIHRvIG1hcGJveCBsYXllcnNcbiAqIEBwYXJhbSBsYXllcnMgdGhlIGxheWVycyB0byBiZSBjb252ZXJ0ZWRcbiAqIEBwYXJhbSBsYXllckRhdGEgZXh0cmEgbGF5ZXIgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSBsYXllck9yZGVyIHRoZSBvcmRlciBieSB3aGljaCB3ZSBzaG91bGQgY29udmVydCBsYXllcnNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVNYXBib3hMYXllcnMobGF5ZXJzID0gW10sIGxheWVyRGF0YSA9IFtdLCBsYXllck9yZGVyID0gW10pIHtcbiAgaWYgKGxheWVyRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGxheWVyT3JkZXIuc2xpY2UoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLnJlZHVjZSgob3ZlcmxheXMsIGlkeCkgPT4ge1xuICAgICAgICBjb25zdCBsYXllciA9IGxheWVyc1tpZHhdO1xuXG4gICAgICAgIHJldHVybiBsYXllci5vdmVybGF5VHlwZSAhPT0gT1ZFUkxBWV9UWVBFLm1hcGJveGdsID9cbiAgICAgICAgICBvdmVybGF5c1xuICAgICAgICAgIDogW1xuICAgICAgICAgICAgLi4ub3ZlcmxheXMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkOiBsYXllci5pZCxcbiAgICAgICAgICAgICAgZGF0YTogbGF5ZXJEYXRhW2lkeF0uZGF0YSxcbiAgICAgICAgICAgICAgY29uZmlnOiBsYXllckRhdGFbaWR4XS5jb25maWcsXG4gICAgICAgICAgICAgIGRhdGFzZXRJZDogbGF5ZXIuY29uZmlnLmRhdGFJZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgIH0sIFtdKTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn07XG5cbi8qKlxuICogVXBkYXRlIG1hcGJveCBsYXllcnMgb24gdGhlIGdpdmVuIG1hcFxuICogQHBhcmFtIG1hcFxuICogQHBhcmFtIG5ld0xheWVycyBBcnJheSBvZiBuZXcgbWFwYm94IGxheWVycyB0byBiZSBkaXNwbGF5ZWRcbiAqIEBwYXJhbSBvbGRMYXllcnMgTWFwIG9mIHRoZSBvbGQgbGF5ZXJzIHRvIGJlIGNvbXBhcmUgd2l0aCB0aGUgY3VycmVudCBvbmVzIHRvIGRldGVjdCBkZWxldGVkIGxheWVyc1xuICogICAgICAgICAgICAgICAgICB7bGF5ZXJJZDogZGF0YXNldElkfVxuICogQHBhcmFtIG1hcExheWVycyBjYXJyaWVzIGluZm9ybWF0aW9uIGFib3V0IHNwbGl0IG1hcCB2aWV3XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVNYXBib3hMYXllcnMobWFwLCBuZXdMYXllcnMgPSBbXSwgb2xkTGF5ZXJzID0gbnVsbCwgbWFwTGF5ZXJzID0gbnVsbCwgb3B0ID0ge2ZvcmNlOiB0cnVlfSkge1xuICAvLyBkZWxldGUgbm9uIGV4aXN0aW5nIGxheWVyc1xuICBpZiAob2xkTGF5ZXJzKSB7XG4gICAgY29uc3Qgb2xkTGF5ZXJzS2V5cyA9IE9iamVjdC5rZXlzKG9sZExheWVycyk7XG4gICAgaWYgKG5ld0xheWVycy5sZW5ndGggPT09IDAgJiYgb2xkTGF5ZXJzS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICBvbGRMYXllcnNLZXlzLmZvckVhY2gobGF5ZXJJZCA9PiBtYXAucmVtb3ZlTGF5ZXIobGF5ZXJJZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgbGF5ZXJzXG4gICAgICBjb25zdCBjdXJyZW50TGF5ZXJzSWRzID0gbmV3TGF5ZXJzLnJlZHVjZSgoZmluYWwsIGxheWVyKSA9PiAoe1xuICAgICAgICAuLi5maW5hbCxcbiAgICAgICAgW2xheWVyLmlkXTogdHJ1ZVxuICAgICAgfSksIHt9KTtcblxuICAgICAgY29uc3QgbGF5ZXJzVG9EZWxldGUgPSBvbGRMYXllcnNLZXlzLnJlZHVjZSgoZmluYWwsIGxheWVySWQpID0+IHtcbiAgICAgICAgLy8gaWYgbGF5ZXIgZG9lc24ndCBleGlzdHMgYW55bW9yZVxuICAgICAgICBpZiAoIWN1cnJlbnRMYXllcnNJZHNbbGF5ZXJJZF0pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZmluYWwsXG4gICAgICAgICAgICBbbGF5ZXJJZF06IG9sZExheWVyc1tsYXllcklkXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmFsO1xuICAgICAgfSwgW10pO1xuICAgICAgT2JqZWN0LmtleXMobGF5ZXJzVG9EZWxldGUpLmZvckVhY2gobGF5ZXJJZCA9PiBtYXAucmVtb3ZlTGF5ZXIobGF5ZXJJZCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc2VydCBvciB1cGRhdGUgbmV3bGF5ZXJcbiAgbmV3TGF5ZXJzLmZvckVhY2gob3ZlcmxheSA9PiB7XG4gICAgY29uc3Qge2lkOiBsYXllcklkLCBjb25maWcsIGRhdGEsIGRhdGFzZXRJZH0gPSBvdmVybGF5O1xuICAgIGlmICghZGF0YSAmJiAhY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzQXZhaWxhYmxlQW5kVmlzaWJsZSA9XG4gICAgICAhKG1hcExheWVycyAmJiBtYXBMYXllcnNbbGF5ZXJJZF0pIHx8IG1hcExheWVyc1tsYXllcklkXS5pc1Zpc2libGU7XG4gICAgLy8gY2hlY2tpbmcgaWYgc291cmNlIGFscmVhZHkgZXhpc3RzXG5cbiAgICBpZiAoZGF0YSAmJiBpc0F2YWlsYWJsZUFuZFZpc2libGUpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1hcC5nZXRTb3VyY2UoZGF0YXNldElkKTtcbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIG1hcC5hZGRTb3VyY2UoZGF0YXNldElkLCB7XG4gICAgICAgICAgdHlwZTogJ2dlb2pzb24nLFxuICAgICAgICAgIGRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc291cmNlLnNldERhdGEoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkQ29uZmlnID0gb2xkTGF5ZXJzW2xheWVySWRdO1xuICAgIGNvbnN0IG1hcGJveExheWVyID0gbWFwLmdldExheWVyKGxheWVySWQpO1xuICAgIC8vIGNvbXBhcmUgd2l0aCBwcmV2aW91cyBjb25maWdzXG5cbiAgICBpZiAoIW9sZENvbmZpZyB8fCBvbGRDb25maWcgIT09IGNvbmZpZyB8fCAhbWFwYm94TGF5ZXIgfHwgb3B0LmZvcmNlKSB7XG4gICAgICAvLyBjaGVjayBpZiBsYXllciBhbHJlYWR5IGlzIHNldFxuICAgICAgLy8gcmVtb3ZlIGl0IGlmIGV4aXN0c1xuICAgICAgaWYgKG1hcGJveExheWVyKSB7XG4gICAgICAgIG1hcC5yZW1vdmVMYXllcihsYXllcklkKTtcbiAgICAgIH1cbiAgICAgIC8vIGFkZCBpZiB2aXNpYmxlIGFuZCBhdmFpbGFibGVcbiAgICAgIGlmIChpc0F2YWlsYWJsZUFuZFZpc2libGUpIHtcbiAgICAgICAgbWFwLmFkZExheWVyKGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgLy8gVE9ETzogdGhpbmsgYWJvdXQgcmVtb3Zpbmcgc291cmNlc1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHBvaW50c1xuICogQHBhcmFtIGNvbHVtbnMge1xuICogbGF0OiB7ZmllbGRJZHh9LFxuICogbG5nOiB7ZmllbGRJZHh9LFxuICogYWx0OiB7ZmllbGRJZHh9XG4gKiB9XG4gKiBAcGFyYW0gcHJvcGVydGllcyBbe2xhYmVsOiB7ZmllbGRJZHh9XVxuICogQHJldHVybnMge3t0eXBlOiBzdHJpbmcsIHByb3BlcnRpZXM6IHt9LCBmZWF0dXJlczoge3R5cGU6IHN0cmluZywgcHJvcGVydGllczoge30sIGdlb21ldHJ5OiB7dHlwZTogc3RyaW5nLCBjb29yZGluYXRlczogKltdfX1bXX19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW9qc29uRnJvbVBvaW50cyhhbGxEYXRhID0gW10sIGZpbHRlcmVkSW5kZXggPSBbXSwgY29sdW1ucyA9IHt9LCBwcm9wZXJ0aWVzID0gW10pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgIGZlYXR1cmVzOiBmaWx0ZXJlZEluZGV4Lm1hcChpbmRleCA9PiBhbGxEYXRhW2luZGV4XSkubWFwKHBvaW50ID0+ICh7XG4gICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLnJlZHVjZSgoZmluYWwsIHByb3BlcnR5KSA9PiAoe1xuICAgICAgICAuLi5maW5hbCxcbiAgICAgICAgW3Byb3BlcnR5Lm5hbWVdOiBwb2ludFtwcm9wZXJ0eS50YWJsZUZpZWxkSW5kZXggLSAxXVxuICAgICAgfSksIHt9KSxcbiAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgY29sdW1ucy5sbmcgPyBwb2ludFtjb2x1bW5zLmxuZy5maWVsZElkeF0gOiBudWxsLCAvLyBsbmdcbiAgICAgICAgICBjb2x1bW5zLmxhdCA/IHBvaW50W2NvbHVtbnMubGF0LmZpZWxkSWR4XSA6IG51bGwsIC8vIGxhdFxuICAgICAgICAgIGNvbHVtbnMuYWx0aXR1ZGUgPyBwb2ludFtjb2x1bW5zLmFsdGl0dWRlLmZpZWxkSWR4XSA6IDAgLy8gYWx0aXR1ZGVcbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKVxuICB9O1xufVxuIl19